<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Astilt&#39;s blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2024-03-05T10:19:20.483Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Astilt</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hive分区表</title>
    <link href="http://yoursite.com/2024/03/05/hive%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <id>http://yoursite.com/2024/03/05/hive%E5%88%86%E5%8C%BA%E8%A1%A8/</id>
    <published>2024-03-05T08:41:18.000Z</published>
    <updated>2024-03-05T10:19:20.483Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -- 创建表</span></span><br><span class="line"><span class="comment">-- CREATE TABLE astilt_par (</span></span><br><span class="line"><span class="comment">--   id INT,</span></span><br><span class="line"><span class="comment">--   name STRING,</span></span><br><span class="line"><span class="comment">--   age INT</span></span><br><span class="line"><span class="comment">-- )</span></span><br><span class="line"><span class="comment">-- PARTITIONED BY (country STRING, city STRING) row format delimited fields terminated by &#x27;\t&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据（静态分区）</span></span><br><span class="line"><span class="comment">-- INSERT INTO TABLE astilt_par PARTITION (country=&#x27;USA&#x27;, city=&#x27;New York&#x27;) VALUES (1, &#x27;John&#x27;, 25);</span></span><br><span class="line"><span class="comment">-- INSERT INTO TABLE astilt_par PARTITION (country=&#x27;USA&#x27;, city=&#x27;San Francisco&#x27;) VALUES (2, &#x27;Jane&#x27;, 30);</span></span><br><span class="line"><span class="comment">-- INSERT INTO TABLE astilt_par PARTITION (country=&#x27;Canada&#x27;, city=&#x27;Toronto&#x27;) VALUES (3, &#x27;Bob&#x27;, 28);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除指定分区</span></span><br><span class="line"><span class="comment">-- ALTER TABLE astilt_par DROP IF EXISTS PARTITION (country=&#x27;USA&#x27;, city=&#x27;New York&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="comment">-- select * from astilt_par;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python虚拟环境</title>
    <link href="http://yoursite.com/2024/02/02/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2024/02/02/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2024-02-02T03:04:39.000Z</published>
    <updated>2024-02-28T07:03:53.303Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://sspai.com/post/75978">https://sspai.com/post/75978</a></p><p>最开始使用 Python 时，相信很多读者都会安装一个全局的（Global）Python 解释器，然后就用这唯一的解释器去学习、并运行 Python 代码。</p><p>由于 Python 有着丰富的社区生态，在使用 Python 的过程中我们不可避免地会去安装别人写好的模块、库或包，而它们都可以被统称为依赖（Dependency）。依赖一词通俗易懂，它就好比是深陷于恋爱泥潭之中无法自拔的小情侣，如果离开了另一方就活不下去的那种状态。在我们的 Python 代码中如果缺少了这些第三方模块、库或包也同样无法正常运行。</p><p>为了安装依赖，我们也因此会接触到一个名为 <a href="https://sspai.com/link?target=https%3A%2F%2Fgithub.com%2Fpypa%2Fpip">pip</a> 的安装与管理工具，并且不论是在正文还是在综合案例实践中，我们都会经常用到该工具。只有通过 <code>pip</code> 工具安装之后我们才能在代码中导入并使用第三方内容。<code>pip</code> 工具通常会随着 Python 解释器一起被安装，并且与对应的解释器版本相绑定。</p><p>但对于 Python 工程师来说，在工作时通常会接触到不同的工程项目（Project），而每个项目可能会使用到不同的 Python 版本，比如老旧的项目 A 使用 Python 2.7，最新的项目使用 Python 3.9，而不旧不新的已经上线的项目一般都使用 Python 3.7 等等。不同的 Python 版本具有不同的功能特性，相关依赖对这些版本的兼容情况又有所不同，所以我们无法直接用一个最新的版本来充当「万金油」。</p><p>在这种场景之下，只有一个唯一的全局解释器仅仅只能满足其中一个项目的需要。所以就需要一种机制可以让我们随时创建或删除不同的 Python 解释器，于是虚拟环境（Virtual environment）也就应运而生。</p><p>使用虚拟环境的好处在于：</p><ul><li>一方面，可以帮我们快速创建干净、完全隔离的且不同版本的 Python 解释器以便我们能在不同项目中开发；</li><li>另一方面，可以避免因在不同项目中只使用唯一的全局解释器而导致的<strong>依赖冲突问题</strong>（Dependency Conflicts）。</li></ul><p>依赖冲突是一个情况复杂的问题，不仅存在于 Python 中，在其他编程语言中也它也「声名远扬」，这里笔者以一个简单的例子说明：</p><p>假设我们现在有两个工程项目 <code>PA</code> 与 <code>PB</code>，它们分别使用到了 Django 2.0 和 Django 3.1（假设为最新版本）依赖。</p><p>在不使用虚拟环境而仅使用一个全局的 Python 3.6 解释器的情况，仅能存在一个 Django 版本：</p><ul><li>在 <code>PA</code> 项目中使用 <code>pip install django==2.0</code> 只会令当前解释器安装 Django 2.0 版本；</li><li>倘若此时在 <code>PB</code> 项目中使用 <code>pip install django</code> 不指定版本号时，默认安装最新的 Django 3.1 版本，于是此时全局解释器中已经存在的 Django 2.0，则会为 Django 3.1 版本所覆盖并升级。</li></ul><p>此时问题来了：如果我们要让 <code>PA</code> 项目能正常运行，就必须使用 Django 2.0，如果要令 <code>PB</code> 项目正常运行，那么就必须使用 Django 3.1。</p><p>而这个问题就是典型的的依赖冲突。</p><p>所以，为了避免这种依赖冲突的情况发生，在开发或运行项目前，通常会使用虚拟环境来创建一个纯净的 Python 运行环境，当中仅仅包含了 Python 解释器和必要的 <code>pip</code> 工具而没有任何第三方依赖。这个环境就类似于我们常说的「沙盒」（SandBox），在盒子内的东西既不会影响外部的事物，也不会被外部事物所影响。</p><p>于是乎为了解决上面所提到的依赖冲突问题，我们只需要分别新建一个包含了 Django 2.0 和包含了 Django 3.1 的虚拟环境，然后运行项目代码时切换到对应的虚拟环境即可。</p><p>这也就是为什么我们需要一个虚拟环境，因为只有<strong>统一的开发环境，才能确保程序在每个能拿到这份代码的协作者手中都是能跑起来的</strong>。就好比在中学时一个班里的同学水平有高有低，但都是要在同一个考场考试、做的都是同一套试卷一样。</p><p>尽管人们常说 Python 是门规范很宽松的语言，因此易于学习与使用，但也正是因为这样的「放任」才会出现了四分五裂的 Python 环境解决方案：</p><p><img src="https://cdn.sspai.com/2022/09/28/article/27f83a110fd22e1730cbe80d8e3767ff?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><h2 id="破局python-中那些创建虚拟环境与解决依赖冲突的方案"><a class="markdownIt-Anchor" href="#破局python-中那些创建虚拟环境与解决依赖冲突的方案"></a> 破局：Python 中那些创建虚拟环境与解决依赖冲突的方案</h2><p>经过前一节的介绍，相信读者已经对「为什么需要有虚拟环境」这一问题有了基本的了解。</p><p>由于 Python 是门规范较为宽松的编程语言，而 Python 官方在早期对于虚拟环境或依赖管理并没有一个统一的解决方案，因此也就在民间出现了各种「非官方实现的」解决手段。</p><p>在 Python 社区生态里，我们可以有多种方式去创建一个干净虚拟环境，本小节笔者主要会简单介绍四个：</p><ol><li>venv</li><li>virtualenv</li><li>conda</li><li>poetry</li></ol><h2 id="venv"><a class="markdownIt-Anchor" href="#venv"></a> venv</h2><p><a href="https://sspai.com/link?target=https%3A%2F%2Fdocs.python.org%2Fzh-cn%2F3%2Flibrary%2Fvenv.html">venv</a> 是 Python 官方在 Python 3.3 版本内置的一个标准库模块，其主要功能移植自 Virtualenv（在下一小节中展开），让我们可以快速生成一个虚拟环境。现在我们只要下载的 Python 解释器版本在 3.3 及以上就能直接使用，而无需安装其他依赖。</p><p>使用它的方式十分简单，只需要通过使用对应版本的 Python 解释器并运行以下命令即可，比如这里我们以 Python 3.10 版本解释器为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python3.10 -m venv &lt;your-virtual-environment-name&gt;</span></span><br></pre></td></tr></table></figure><p>通常我们在创建虚拟环境时需，要简单指定一个名称用以存放虚拟环境的内容，所以上述代码中的名称通常就保持和 <code>venv</code> 模块名称一致：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python3.10 -m venv venv</span></span><br></pre></td></tr></table></figure><p>通过对应版本的 Python 解释器调用 <code>venv</code> 模块得到的虚拟环境，其版本也与解释器保持一致，也即在创建的 <code>venv</code> 目录中期 Python 解释器也为 3.10。并且在不指定目录的情况下，默认会在当前运行命令的目录中创建虚拟环境。</p><p>目前像 Pycharm 这样的 IDE 或 VS Code 类似的文本编辑器（需要安装插件）已经会正确识别到 <code>venv</code> 目录，并在运行代码时自动帮我们切换到虚拟环境中。</p><p>但如果我们是在终端上手动切换虚拟环境，那么就需要自己进行手动激活（Active）。由于 <code>venv</code> 模块创建的虚拟环境目录在 macOS 和 Windows 内容有所不同，所以就导致二者在激活虚拟环境时的命令也有所差异。</p><p>在 macOS 中，激活命令 <code>active</code> 会存放在同名的 <code>venv</code> 目录下的 <code>bin/</code> 目录中。但在使用前需要如下图所示，通过 Unix 中的 <code>chmod +x</code> 命令赋予激活命令执行权限。如果读者有像笔者一样事先对终端命令行界面进行了美化相关的设置，那么激活之后就能看到如图所示的环境名前缀（或后缀）提示符，这就表示我们已经成功切换到虚拟环境中；</p><p><img src="https://cdn.sspai.com/2022/09/28/article/b4503099a78b04b86feef8fa4ea0af90?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>而在 Windows 系统 <code>bin/</code> 目录则为 <code>Scripts/</code> 目录，操作上同理。</p><p>后续我们陆续介绍到的虚拟环境管理工具，除了 IDE 帮我们自动切换之外，大部分时候如果是在终端运行，那么就需要自己通过对应的激活命令手动切换。</p><p>当然，如果我们想要退出虚拟环境，要么直接关闭 IDE，要么直接在终端命令行界面输入 <code>deactivate</code> 命令即可（或是同样关闭终端）。</p><p>不过使用 <code>venv</code> 模块存在一个令人头疼的问题：如果我们有多个项目，那么就会存在多个由 <code>venv</code> 创建的虚拟环境，因此我们无法做到<strong>统一集中管理</strong>。</p><p>所以，Python 社区的里的其他方案也意识到了这一点，也都具备了统一在一个命令中管理虚拟环境的功能。</p><h2 id="virtualenv"><a class="markdownIt-Anchor" href="#virtualenv"></a> Virtualenv</h2><p><a href="https://sspai.com/link?target=https%3A%2F%2Fvirtualenv.pypa.io%2Fen%2Flatest%2F">Virtualenv</a> 是 Python 社区一款老牌、成熟的虚拟环境管理工具，经过多个版本迭代也具备丰富的功能。并且自从 Python 3.3 版本开始，它的部分功能已也被集成到了 venv 标准库中，足见其对于 Python 虚拟环境管理工作贡献的份量如何。</p><p>从某些程度上来说，Virtualenv 和 venv 的功能十分类似，但 Virtualenv 在其官方文档中也指出了 venv 的不足之处：</p><ul><li>is slower（创建速度慢）</li><li>is not as extendable（可扩展性差）</li><li>cannot create virtual environments for arbitrarily installed python versions（无法创建任意 Python 版本的虚拟环境）</li><li>is not upgrade-able via pip（无法通过 pip 进行升级）</li><li>does not have as rich programmatic API（没有丰富的 API 编程方法扩展）</li></ul><p>而这些不足之处在 Virtualenv 里都有了比较完善的解决方案。</p><p>不过由于 virtualenv 本质上属于一个第三方工具，因此我们要使用 virtualenv 首先就得通过 <code>pip</code> 命令安装它。这里的 <code>pip</code> 命令存在于在全局解释器中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可能因为网络问题报错，需要进行终端代理 eg: <span class="built_in">export</span> http_proxy=http://127.0.0.1:7890</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install virtualenv --user</span></span><br></pre></td></tr></table></figure><p>安装成功后，它的用法也和 venv 十分类似，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意需要virtualenv&lt;.exe&gt;加入环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> virtualenv myenv</span></span><br></pre></td></tr></table></figure><p>上述命名会在当前路径中多出一个名为 <code>myenv</code> 的 Python 虚拟环境，使用它时我们同样可以像使用 venv 模块那样，通过同样的命令去激活环境。</p><p>不过这样本质上和我们用 venv 没有太大的区别。由于 Virtualenv 提供了可供扩展的 API 接口，因此我们通常还需要借助第三方的 Virtualenv 扩展，来帮助我们完成统一管理环境的操作，而 Virtualenvwrapper 就是这样一个能满足我们需求的第三方扩展库。</p><p>见名知意，<a href="https://sspai.com/link?target=https%3A%2F%2Fvirtualenvwrapper.readthedocs.io%2Fen%2Flatest%2F">Virtualenvwrapper</a> 实际是对 Virtualenv 进行包装（Wrap）的扩展库，我们在使用时一样需要通过 <code>pip</code> 工具进行安装安装。完成之后需要简单配置一下环境变量才能继续使用，以下是来自于官方的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install virtualenvwrapper</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> WORKON_HOME=~/Envs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$WORKON_HOME</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkvirtualenv env1</span></span><br></pre></td></tr></table></figure><p>上述的 <code>WORKON_HOME</code> 变量即指定的是统一存放虚拟环境的文件夹路径，创建之后再调用 Virtualenvwrapper 提供的初始化命令进行自动配置，之后就通过 <code>mkvirtualenv</code> 来创建相应的虚拟环境。</p><p>如果我们需要激活环境，则是需要通过 Virtualenvwrapper 帮我们设置好的 <code>worken</code> 命令来激活并切换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> workon env1</span></span><br></pre></td></tr></table></figure><p>虽然 Virtualenvwrapper 是对 Virtualenv 的包装，但它并没有直接使用 Virtualenv 的命令，而是额外构造并提供了一批与虚拟环境相关的命令，读者在使用时最好需要参考其<a href="https://sspai.com/link?target=https%3A%2F%2Fvirtualenvwrapper.readthedocs.io%2Fen%2Flatest%2Fcommand_ref.html">文档</a>。</p><p>需要注意的是，Virtualenvwrapper <strong>主要面向的是 macOS 和 Linux 操作系统</strong>，而如果我们想要在 Windows 上使用这一工具，那就必须要再安装一个由其他开发者二次封装的 <a href="https://sspai.com/link?target=https%3A%2F%2Fgithub.com%2Fdavidmarble%2Fvirtualenvwrapper-win">virtualenvwrapepr-win</a>，但该库也仅支持在 Windows 上的 CMD 终端上使用，而不支持在 Powershell 上使用。</p><h2 id="conda"><a class="markdownIt-Anchor" href="#conda"></a> Conda</h2><p>相信有相当一大部分比例的已经事先学习过 Python 的新手，又或是如果从事数据分析、机器学习等数据科学相关工作的人，在学习或使用过程会经常接触到一个名为 <a href="https://sspai.com/link?target=https%3A%2F%2Fwww.anaconda.com%2F">Anaconda</a> 的 Python 发行版本。在 Anaconda 中不仅内置了一个 Python 解释器，同时还内置了许多常用的数据科学软件包或工具。</p><p>但 Anaconda 为人所诟病的地方也在于它内置了太多东西，其中的大多数又用不到，导致最终体积较大，无异于让配置本就不富裕的电脑雪上加霜。当然 Anaconda 还有另外一个精简版 <a href="https://sspai.com/link?target=https%3A%2F%2Fdocs.conda.io%2Fen%2Flatest%2Fminiconda.html">Miniconda</a>，它只包含了少量的一些依赖库或包，有效减轻了电脑磁盘的负担。</p><p>但不论是使用 Anaconda 还是 Miniconda，我们都会进一步用到它们当中的核心工具——<a href="https://sspai.com/link?target=https%3A%2F%2Fdocs.conda.io%2Fen%2Flatest%2F">Conda</a>，一个跨平台的包（或库）和虚拟环境管理系统，它能轻易地帮我们构建程序运行所需的环境、依赖、更新等步骤。</p><p><img src="https://cdn.sspai.com/2022/09/28/article/6e425fe5b14f4c2afd1f7d6809d95840?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>Conda 最大的一个优势就是它除了能安装 Python 依赖库或包之外，还能安装其他语言的一些依赖（比如 R 语言）；同时像 <a href="https://sspai.com/link?target=https%3A%2F%2Ftensorflow.google.cn%2F">Tensorflow</a>、<a href="https://sspai.com/link?target=https%3A%2F%2Fpytorch.org%2F">Pytorch</a> 这种业内常见的深度学习框架，往往会存在由 C/C++ 语言编写的部分，这些部分在安装时需要预先编译，而使用 Conda 安装时会自动连同已经事先编译好的二进制部分一起安装到虚拟环境中，避免了因操作系统不同而导致的编译问题。</p><p>不像 <code>pip</code> 或 <code>virtualenv</code> 这样的工具我们能够单独安装，要使用 Conda 我们通常会捆绑使用 Anaconda 或者 Miniconda，读者可以根据自己电脑的配置情况选择其一，具体的安装步骤可以直接参考<a href="https://sspai.com/link?target=https%3A%2F%2Fdocs.conda.io%2Fprojects%2Fconda%2Fen%2Flatest%2Fuser-guide%2Finstall%2Findex.html%23installing-conda-on-a-system-that-has-other-python-installations-or-packages">官方文档</a>，上面有着详细的操作过程。</p><p>安装完成之后，当我们在终端命令行中输入如下命令，并能获取到帮助信息就说明安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><p>Conda 命令行工具集成了众多的功能，以至于我们可以用 Conda 命令行工具来完成大部分操作，读者可以参考 Conda 官方的 <a href="https://sspai.com/link?target=https%3A%2F%2Fdocs.conda.io%2Fprojects%2Fconda%2Fen%2Flatest%2Fcommands.html">Command reference</a> 来获取有关命令的详细说明。</p><p>比如使用 Conda 创建虚拟环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name myenv python=3.9</span></span><br></pre></td></tr></table></figure><p>然后激活虚拟环境时只需要通过同样的 <code>active</code> 命令来操作即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda active myenv</span></span><br></pre></td></tr></table></figure><p>当然我们也可以将 Conda 作为 <code>pip</code> 工具来安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install pandas seaborn</span></span><br></pre></td></tr></table></figure><p>不过需要注意的是，尽管我们是在 Anaconda 或 Miniconda 中用到 Conda，但 Python 解释器本身就会自带 <code>pip</code> 工具。因此我们在使用 Conda 的过程中，切勿既通过 <code>conda install</code> 来安装依赖，又通过 <code>pip</code> 工具来安装依赖。</p><p>因为这就好比我们在驾驶时只用右脚来控制刹车和油门，而左脚要么控制离合器要么什么也不做一样，如果混用则极易引发事故。</p><p>这个道理也同样适用于 Conda，倘若我们将 <code>conda</code> 命令与 <code>pip</code> 命令作为安装依赖混用，那么 <strong>有一定几率产生的依赖冲突的 BUG</strong>。除此之外，通过 Conda 安装的版本有时候会比 <code>pip</code> 安装的版本会落后一些，并且 Conda 在安装前会检查环境依赖或更新情况，因此速度会相对较慢（不知道现在有没有改善）。</p><p>所以如果读者有打算使用 Conda 的想法，那么笔者<strong>强烈建议读者只将其用来创建、管理虚拟环境</strong>，而不是用来安装第三方依赖库或包。具体来说，就是通过 Conda 创建一个用于编写代码或程序的虚拟环境，然后再通过虚拟环境中的 <code>pip</code> 工具安装需要使用到的第三方依赖库或包即可。</p><p>使用 Conda 创建特定 Python 版本的虚拟环境时，Conda 会从默认的服务器上下载相关资源并构建。但由于 Conda 的服务器位于国外，在国内访问时会受到网络限制，这也进一步而影响到 Conda 的更新功能，因此在使用 Conda 之前我们最好像配置 <code>pip</code> 工具一样为 Conda 添加镜像源。</p><p>但好在清华大学开源软件镜像站包含 Conda 的镜像源，我们只需要按照 <a href="https://sspai.com/link?target=https%3A%2F%2Fmirror.tuna.tsinghua.edu.cn%2Fhelp%2Fanaconda%2F">《Anaconda 镜像使用帮助》</a> 文档中的内容进行配置即可，本节就不过多赘述。</p><h2 id="poetry"><a class="markdownIt-Anchor" href="#poetry"></a> Poetry</h2><p><a href="https://sspai.com/link?target=https%3A%2F%2Fpython-poetry.org%2F">Poetry</a> 是一个面向未来的 Python 依赖管理和打包工具（笔者按：这里的「包」是指能够被其他人作为依赖安装的安装包，而非单独的应用程序），它支持了 Python 社区的 <a href="https://sspai.com/link?target=https%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0518%2F">PEP 518</a> 提案里的 <code>pyproject.toml</code> 新标准文件，用以管理我们与 Python 项目有关的内容（比如我们在 Click 实践案例中见到的 <code>setup.py</code> 打包文件）。</p><p>有了 <code>pyproject.toml</code> 文件之后我们再也不需要在 Python 项目中包含额外的说明、许可证文件、依赖文件 <code>requirements.txt</code> 等，统统由这个文件统一管理。</p><p>Poetry 就像 Go 语言的 <a href="https://sspai.com/link?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fwiki%2FModules">Go mod</a>、Rust 语言的 <a href="https://sspai.com/link?target=https%3A%2F%2Fdoc.rust-lang.org%2Fcargo%2F">Cargo</a> 工具一样，都是顺应着未来依赖管理更容易、开发更简单的趋势。目前已经可以看到有许多知名的 Python 开源项目都逐渐开始通过这一工具来管理，并且也都开始采用 <code>pyproject.toml</code> 文件。</p><p>虽然 Poetry 主要用于管理依赖和打包 Python 项目，但我们在使用 Poetry 时它也会自动创建一个包含了特定版本的 Python 解释器的虚拟环境，所以也可以算作是一个虚拟环境管理工具。</p><p>当然我们在使用 Poetry 时依旧需要通过 <code>pip</code> 命令对其进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install poetry</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip3 install poetry</span></span><br></pre></td></tr></table></figure><p>使用 Poetry 步骤其实也和笔者前面所介绍的其他虚拟环境管理工具类似，即在使用时需要像 Conda 那样通过命令行来操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> poetry &lt;<span class="built_in">command</span>&gt; ...</span></span><br></pre></td></tr></table></figure><p>使用 Poetry 的方式很简单，对于我们个人来说通常都是几步：</p><ol><li>通过 Poetry 初始化项目。这里的初始化包括新建项目并初始化和对已创建项目初始化两种情况。</li><li>根据实际情况选择对应版本的 Python 解释器。默认情况下跟 Poetry 所使用的解释器版本相一致。</li><li>添加必要依赖（Required Dependencies）或开发依赖。</li><li>通过 Poetry 运行或启动项目和我们的代码。</li></ol><h3 id="初始化项目"><a class="markdownIt-Anchor" href="#初始化项目"></a> 初始化项目</h3><p>如果我们已经存在了项目文件夹，那么就可以再使用 <code>poetry init</code> 来为已存在的项目生成 <code>pyproject.toml</code> 文件。当然我们也可以使用 <code>poetry new</code> 来直接创建一个项目，不过得到的结构文件需要自己手动调整以符合需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir myproject</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myproject</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> poetry init</span></span><br></pre></td></tr></table></figure><p>之后我们在 <code>myproject</code> 这个项目文件夹下，就可以看到 <code>pyproject.toml</code> 文件，其内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[tool.poetry]</span><br><span class="line">name &#x3D; &quot;myproject&quot;</span><br><span class="line">version &#x3D; &quot;0.1.0&quot;</span><br><span class="line">description &#x3D; &quot;&quot;</span><br><span class="line">authors &#x3D; [&quot;None&quot;]</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python &#x3D; &quot;^3.9&quot;</span><br><span class="line"></span><br><span class="line">[tool.poetry.dev-dependencies]</span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires &#x3D; [&quot;poetry-core&gt;&#x3D;1.0.0&quot;]</span><br><span class="line">build-backend &#x3D; &quot;poetry.core.masonry.api&quot;</span><br></pre></td></tr></table></figure><p>通过 <code>poetry</code> 初始化生成的 <code>pyproject.toml</code> 文件内容并不多，它会在我们后续添加相关依赖的时候被不断丰富。</p><p>所以一般情况下我们也不需要手动修改它，因为我们通过 <code>poetry</code> 命令行工具进行某些操作时，Poetry 会帮我们自动增删当中的内容。</p><p>需要注意的是：因为 Poetry 的大多数操作都是围绕 <code>pyproject.toml</code> 进行展开的，因此<strong>一定要在包含该文件的目录环境中使用 Poetry 操作</strong>，否则会报错。</p><h3 id="选择相应版本的-python-解释器"><a class="markdownIt-Anchor" href="#选择相应版本的-python-解释器"></a> 选择相应版本的 Python 解释器</h3><p>初始化项目之后 Poetry 还并未为我们构建一个 Python 的虚拟环境。因为它会在我们添加依赖的时候默认创建，而这个虚拟环境的 Python 解释器版本和调用 Poetry 时所用到的 Python 释器版本一致，因此通常我们并不需要额外指定。</p><p>但如果你有特殊需要，需要 Poetry 为项目构建一个使用指定版本 Python 解释器的虚拟环境，那么你可以使用 <code>poetry env use &lt;special-version-python-interpreter-path&gt;</code> 来进行构建。其中 <code>use</code> 后面输入的是指定版本的 Python 解释器路径。</p><p>但因为 <code>pyproject.toml</code> 中 <code>tool.poetry.dependencies</code> 部分指明了 <code>python=&quot;^3.9&quot;</code> 参数，即该项目使用的 Python 解释器最低版本为 3.9，因此我们如果指定的特定版本不在兼容范围内，那就需要我们手动修改。这里直接使用一般的文本编辑器修改完成后保存即可。</p><p>比如我们目前需要使用系统里存在的 Python 3.7 解释器，那么所以需要将 <code>python=&quot;^3.9&quot;</code> 改成 <code>python=&quot;^3.7&quot;</code> 然后再指定解释器路径即可。</p><p><code>^</code>符号是一个特殊的版本限定符号，在 Poetry 官方文档的<a href="https://sspai.com/link?target=https%3A%2F%2Fpython-poetry.org%2Fdocs%2Fdependency-specification%2F%23version-constraints">这一节</a>内容中可以找到关于这个及其他同类符号的所有说明。</p><p>在 Windows 下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Linxiaoyue\Desktop\myproject&gt; poetry env use &#x27;D:\Program Files\Python\python37\python.exe&#x27;</span><br></pre></td></tr></table></figure><p>在 macOS 或 Linux 下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> poetry env use /usr/<span class="built_in">local</span>/python/python37/bin/python</span></span><br></pre></td></tr></table></figure><p>指定完成并运行命令之后，我们就可以在终端命令行界面上看到 Poetry 帮我们创建了一个虚拟环境及其存放的路径。</p><h3 id="管理依赖"><a class="markdownIt-Anchor" href="#管理依赖"></a> 管理依赖</h3><p>如果我们没有指定特定版本的 Python 解释器，那么直到我们添加依赖时 Poetry 才会帮我们创建虚拟环境并将依赖添加到 <code>pyproject.toml</code> 文件中。</p><p>使用 Poetry 管理依赖比较简单，而且有点类似于 JavaScripts 的包管理工具 <a href="https://sspai.com/link?target=https%3A%2F%2Fyarnpkg.com%2F">Yarn</a>；但通常情况下我们要做的也就只有两个操作：<strong>添加和移除</strong>。</p><h4 id="配置镜像路径"><a class="markdownIt-Anchor" href="#配置镜像路径"></a> 配置镜像路径</h4><p>和使用 <code>pip</code> 工具以及 Conda 类似，在安装依赖之前，我们还是需要简单地配置一下 Poetry 安装依赖的镜像地址，避免我们下载依赖时走的是国外镜像仓库的网络，以加快安装过程。</p><p>但默认情况下，如果我们已经有配置了 <code>pip</code> 的镜像，那么 Poetry 则会直接使用该镜像来加速依赖下载过程，这一步配置镜像的过程可以跳过；反之，我们需要在 Poetry 的全局配置中进行设置，配置文件的具体路径如下：</p><ul><li>macOS/Linux：<code>~/Library/Application Support/pypoetry</code></li><li>Windows：<code>C:\Users\&lt;username&gt;\AppData\Roaming\pypoetry</code></li></ul><p>进入到对应的文件夹后，就会看到一个名为 <code>config.toml</code> 的文件，此时我们可以用电脑中的编辑器打开它（推荐 VS Code 之类比较现代的编辑器），之后在当中我们可以选择相应的镜像源，这里我推荐使用豆瓣和清华的镜像源，任选其一即可，编辑完成后保存即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repositories.douban = &quot;https://pypi.doubanio.com/simple&quot;  # 豆瓣镜像源</span><br><span class="line">repositories.tuna = &quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;  # 清华镜像源</span><br></pre></td></tr></table></figure><p>关于 Poetry 配置文件的内容读者可以查阅 <a href="https://sspai.com/link?target=https%3A%2F%2Fpython-poetry.org%2Fdocs%2Fconfiguration%2F">Configuration</a> 一节文档。</p><h4 id="添加依赖add"><a class="markdownIt-Anchor" href="#添加依赖add"></a> 添加依赖：add</h4><p>配置好镜像路径之后，我们就可以直接使用 <code>poetry add &lt;package-name&gt;</code> 就可以安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add requests</span><br></pre></td></tr></table></figure><p>但默认情况下，使用 <code>poetry add</code> 添加的是项目的必要依赖，也即运行项目必须要安装的依赖。</p><p>如果在开发的时候我们不想导出某些在开发环境中使用的依赖，比如（Pytest 之类的第三方测试库），那么在添加依赖时需要使用 Poetry 为我们提供的开发环境依赖（Development Environment Denpendencies）选项 <code>-D</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add -D pytest</span><br></pre></td></tr></table></figure><p>安装成功后我们打开 <code>pyproject.toml</code> 文件中的 <code>tool.poetry.dev-dependencies</code> 就会多出一行 <code>pytest=&quot;^6.2.3&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[tool.poetry]</span><br><span class="line">name &#x3D; &quot;myproject&quot;</span><br><span class="line">version &#x3D; &quot;0.1.0&quot;</span><br><span class="line">description &#x3D; &quot;&quot;</span><br><span class="line">authors &#x3D; [&quot;None&quot;]</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python &#x3D; &quot;^3.7&quot;</span><br><span class="line">requests &#x3D; &quot;^2.25.1&quot;</span><br><span class="line"></span><br><span class="line">[tool.poetry.dev-dependencies]</span><br><span class="line">pytest &#x3D; &quot;^6.2.3&quot;</span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires &#x3D; [&quot;poetry-core&gt;&#x3D;1.0.0&quot;]</span><br><span class="line">build-backend &#x3D; &quot;poetry.core.masonry.api&quot;</span><br></pre></td></tr></table></figure><p>当然我们也可以一次性添加多个依赖，和 <code>pip</code> 工具的使用方式类似，只要通过空格隔开即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add -D black flake8 mypy</span><br></pre></td></tr></table></figure><h4 id="移除依赖remove"><a class="markdownIt-Anchor" href="#移除依赖remove"></a> 移除依赖：remove</h4><p>移除依赖的方法也很简单，我们只需要使用 <code>poetry remove &lt;package-name&gt;</code> 即可。</p><p>一旦运行上述命令，Poetry 会连同依赖的依赖一起移除，确保我们的虚拟环境里没有残留的第三方库或包，这一功能在 <code>pip</code> 工具中并未实现。</p><p>和 <code>add</code> 类似，默认是操作公共依赖，如果只是要移除开发环境依赖，一样需要加上 <code>-D</code> 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry remove -D pytest</span><br></pre></td></tr></table></figure><h3 id="激活虚拟环境"><a class="markdownIt-Anchor" href="#激活虚拟环境"></a> 激活虚拟环境</h3><p>使用 Poetry 激活虚拟环境也比较简单，它和我们前面说的 Conda 类似，即使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry shell</span><br></pre></td></tr></table></figure><p>除此之外，如果我们没创建环境，那么这个命令同样会帮助我们创建一个新的虚拟环境，然后再切换到环境中。</p><p>当然我们也可以不用切换到虚拟环境中，直接使用相关命令执行对应的命令或代码，即使用 <code>poetry run &lt;command&gt;</code>，但这种情况往往<strong>适用于命令较少</strong>的情况下。比如现在我们的项目文件夹中已经存在了一个名为 <code>main.py</code> 文件，此时我们想要在 Poetry 为我们创建好的虚拟环境来运行它，那么就根据命令操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run python main.py</span><br></pre></td></tr></table></figure><p>这里在 <code>run</code> 之后需要接具体运行的命令行工具名称，之后才是参数。</p><h3 id="导出依赖列表"><a class="markdownIt-Anchor" href="#导出依赖列表"></a> 导出依赖列表</h3><p>由于我们使用 <code>pyproject.toml</code> 文件并由 Poetry 来帮助我们管理依赖，如果要是其他人也使用了 Poetry，那么在安装过程中倒是没什么问题，直接运行 <code>poetry install</code> 命令即可；但如果有的人仍使用传统的 <code>pip</code> 方式来安装依赖，那么我们为了兼顾别人，就可能需要额外导出一下我们现有的依赖文件，将其放入传统的 <code>requirements.txt</code> 文件中。</p><p>此时 Poetry 也给我们提供了一种导出的方式，即 <code>poetry export</code> 命令。这里我们需要加上 <code>-o</code> 选项输出到 <code>requirements.txt</code> 文件中，这个文件会自动在这个过程中被创建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry export -o requirements.txt</span><br></pre></td></tr></table></figure><p>默认情况下，Poetry 会连同依赖对应版本的校验哈希值一起导出，并且只导出全局依赖；因此我们可以分别通过加上 <code>--without-hashes</code> 和 <code>--dev</code> 选项来导出适合的依赖文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不导出 Hash 值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> poetry <span class="built_in">export</span> --without-hashes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导出开发依赖</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> poetry <span class="built_in">export</span> --without-hashes --dev</span></span><br></pre></td></tr></table></figure><p>以上就是 Poetry 最常见的一些用法，更多关于 Poetry 的操作和用法可以进一步参考 Poetry 的<a href="https://sspai.com/link?target=https%3A%2F%2Fpython-poetry.org%2Fdocs%2F">官方文档</a>。</p><h2 id="作为一个-python-工程师我是如何选择"><a class="markdownIt-Anchor" href="#作为一个-python-工程师我是如何选择"></a> 作为一个 Python 工程师，我是如何选择？</h2><p>通过以上的介绍，可能读者已经对 Python 社区中虚拟环境管理的方案已经有了一定的认识。读者可能也想知道像笔者这样作为一个日常使用 Python 的开发工程师，会选择上述哪种方案的以及当中的优劣如何。</p><p>因此在本章这最后的一小节里，笔者主要谈谈不论是在工作还是个人项目中，使用上述虚拟环境管理工具时的体验感受以及使用建议。</p><h3 id="venv快速实验与使用的好帮手"><a class="markdownIt-Anchor" href="#venv快速实验与使用的好帮手"></a> venv：快速实验与使用的好帮手</h3><p>如果读者不是专门的 Python 开发工程师，那通常也很少接触到大型的或结构固定的项目代码，更多时候可能也只是出于个人兴趣或是在工作中将 Python 作为脚本使用。</p><p>因此如果不想太过折腾虚拟环境，又想避免把当前操作系统中的 Python 环境搞乱，那么最好的方式就是每次实践的过程中，用 Python 解释器自带的 <code>venv</code> 模块来快速生成一个干净的 Python 虚拟环境。</p><p>默认情况下它会直接根据当前所使用的 Python 解释器进行克隆，同时也会将生成的虚拟环境文件夹放在当前的文件路径中。比如我们现在桌面上有一个用于练习的 <code>lab</code> 文件夹当中存放着我们的代码，那么通过解释器自带的 <code>venv</code> 模块创建一个同名的 <code>venv</code> 虚拟环境文件夹之后，就会可以基于当中命令来运行我们的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lab</span><br><span class="line"> ├── main.py</span><br><span class="line"> └── venv</span><br><span class="line">     ├── bin</span><br><span class="line">     ├── include</span><br><span class="line">     ├── lib</span><br><span class="line">     └── pyvenv.cfg</span><br></pre></td></tr></table></figure><p>注：venv 在 Windows 下创建的目录可能会和上述内容有所不同，即用一个名为 Scripts 的文件夹来存放相关命令而非上述内容中的 bin 文件夹。</p><p><code>venv</code> 模块的缺点在于创建后的虚拟环境是完全独立的克隆体，无法被很好地统一管理，年代久远的情况下，可能就散落在自己都不曾注意的犄角旮旯文件夹中占用磁盘空间。但换句话来，说如果我们也只要将存放了 <code>venv</code> 生成的虚拟环境的项目文件夹删除，那么虚拟环境也就会被清理。</p><p>不过好处在于目前大部分的 IDE 或编辑器——比如 Pycharm、VS Code 等——都支持探测 <code>venv</code> 所生成的虚拟环境的功能。如果发现当前项目文件夹中存在了由 <code>venv</code> 模块创建的虚拟环境，那么也会自动将执行代码需要的 Python 解释器命令切换为虚拟环境中的解释器命令。</p><h3 id="virtualenv有口皆碑的传统厂牌"><a class="markdownIt-Anchor" href="#virtualenv有口皆碑的传统厂牌"></a> Virtualenv：有口皆碑的传统厂牌</h3><p>Virtualenv 作为历史悠久、到目前也一直维护更新的虚拟环境的创建工具，一直都是有口皆碑且在使用中也是「稳如泰山」。虽然 <code>venv</code> 模块脱胎于 Virtualenv，但却不是完全移植，因此缺乏某些 Virtualenv 才有的功能，比如不能手动基于其他 Python 版本来创建虚拟环境。</p><p>因此，不论是刚接触 Python 的新手，还是在日常的开发中，使用 Virtualenv 这样老牌的工具来创建虚拟环境一般也没有什么问题。因为 Virtualenv 本身就历史悠久，已经更新迭代多个版本，其 API 方法或使用方式也相对稳定，对于已经使用过该工具来管理的开发者来说无疑是降低学习成本的好事情。即便在使用 Virtualenv 的过程中出现了一时无法解决的问题，那么在网上也能找到相对多的参考资料提供相应的解决方案。</p><p>Virtualenv 通常需要搭配 <code>virtualenvwrapper</code> 这一扩展工具来使用，特别是当我们系统中存在多个虚拟环境时，并且我们需要经常在这些虚拟环境中进行切换的场景时尤为有用。通过 <code>virtualenvwrapper</code> 我们可以快速实现查看当前虚拟环境以及创建、删除虚拟环境等，不过 <code>virtualenvwrapper</code> 在前期配置上会稍微有些繁琐。</p><h3 id="conda数据科学和离线-linux-环境最好的选择"><a class="markdownIt-Anchor" href="#conda数据科学和离线-linux-环境最好的选择"></a> Conda：数据科学和离线 Linux 环境最好的选择</h3><p>对于数据科学，尤其是会涉及到机器学习、深度学习领域的使用者而言，Conda 应该是最好的选择。</p><p>因为不论是 Anaconda 还是 Miniconda 它们都是在 Conda 基础之上发展而来，都已经事先内置了一系列开箱即用的依赖库或第三库，对于新手而言比较友好，一定程度上可以规避掉安装依赖时的某些问题。并且 Conda 最大的优势在于，如果所使用的依赖库核心会使用类似于 C 或 C++ 语言的额外代码比如 <a href="https://sspai.com/link?target=https%3A%2F%2Fpytorch.org%2F">PyTorch</a> 或 <a href="https://sspai.com/link?target=https%3A%2F%2Fwww.tensorflow.org%2F%3Fhl%3Dzh-cn">TensorFlow</a> 这样深度学习框架，那么通常在 Conda 的官方仓库上都有事先已经编译并被打包好的版本，可以直接通过命令一键安装而无须使用者手动编译。</p><p>同时，如果要在<strong>无网络环境</strong>的 Linux 服务器上使用 Python，那么 Conda 毫无疑问是有着绝对优势。</p><p>这里的无网络环境也就是所谓的「Offline」离线环境，这通常在 <strong>信息安全保密性要求较高</strong> 的企业或机构部门中最为常见。如果我们需要在该环境中安装东西，就必须事先在自己的电脑上提前下载并传入类似于光盘、U 盘之类的传输介质之中，导入至指定的文件路径再进行操作，十分繁琐。</p><p>而 Python 官方目前仅提供了 Windows 和 macOS 两个版本的便捷安装包，而 Linux 版本则不存在便捷安装包一说，需要使用者自己手动编译。除此之外，由于 Python 的官方版本解释器是由 CPython 来实现（即由 C 语言实现），编译时需要涉及到众多的动态链接库，但凡缺少一个最后都会导致某个功能无法正常使用。</p><p>所以这时候 Conda 也再次派上用场。</p><p>我们只需要通过 Conda 来创建指定 Python 版本的虚拟环境，然后将各种依赖事先安装，直接将整个环境打包成压缩包，最后再走一遍传输的流程并在 Linux 服务器上直接解压并使用即可。</p><p>通过 Conda 所创建的虚拟环境其实也就对应了一个 Python 解释器，并且它会自动为我们链接运行解释器所需要的一些动态链接库，这就是为什么我们可以直接拷贝解压之后就可以直接使用。</p><h3 id="poetry标新立异的个人首选"><a class="markdownIt-Anchor" href="#poetry标新立异的个人首选"></a> Poetry：标新立异的个人首选</h3><p>如果是<strong>现在</strong>个人项目或者用于开源项目，那么目前被广泛的使用的 Poetry 可以算是依赖与虚拟环境管理的首选。比如我们在实践案例中用到的 FastAPI 就主要使用 Poetry。</p><p>一方面 Poetry 会在首次初始化时自动为项目创建一个虚拟环境，之后我们只需要在 IDE 或编辑器中指定该环境的解释器即可；另一方面，Poetry 不同于单一的 <code>pip</code> 工具，它除了提供依赖解析与安装功能之外，还支持对项目代码进行打包，而与之相关的内容或参数都统一放到来自于 PEP 518 这一 Python 增强提案的 <code>pyproject.toml</code> 配置文件中。</p><p>同时，Poetry 在安装和使用上类似于 <a href="https://sspai.com/link?target=https%3A%2F%2Fyarnpkg.com%2F">Yarn</a> 这一 JavaScripts 包管理工具，不论是添加、更新还是删除依赖，都会生成一个名为 <code>poetry.lock</code> 的版本锁或依赖锁文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># poetry.lock</span><br><span class="line"></span><br><span class="line">[[package]]</span><br><span class="line">name &#x3D; &quot;click&quot;</span><br><span class="line">version &#x3D; &quot;8.1.2&quot;</span><br><span class="line">description &#x3D; &quot;Composable command line interface toolkit&quot;</span><br><span class="line">category &#x3D; &quot;main&quot;</span><br><span class="line">optional &#x3D; false</span><br><span class="line">python-versions &#x3D; &quot;&gt;&#x3D;3.7&quot;</span><br><span class="line"></span><br><span class="line">[package.dependencies]</span><br><span class="line">colorama &#x3D; &#123;version &#x3D; &quot;*&quot;, markers &#x3D; &quot;platform_system &#x3D;&#x3D; \&quot;Windows\&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">[metadata.files]</span><br><span class="line">click &#x3D; [</span><br><span class="line">    &#123;file &#x3D; &quot;click-8.1.2-py3-none-any.whl&quot;, hash &#x3D; &quot;sha256:24e1a4a9ec5bf6299411369b208c1df2188d9eb8d916302fe6bf03faed227f1e&quot;&#125;,</span><br><span class="line">    &#123;file &#x3D; &quot;click-8.1.2.tar.gz&quot;, hash &#x3D; &quot;sha256:479707fe14d9ec9a0757618b7a100a0ae4c4e236fac5b7f80ca68028141a1a72&quot;&#125;,</span><br><span class="line">]</span><br><span class="line">colorama &#x3D; [</span><br><span class="line">    &#123;file &#x3D; &quot;colorama-0.4.4-py2.py3-none-any.whl&quot;, hash &#x3D; &quot;sha256:9f47eda37229f68eee03b24b9748937c7dc3868f906e8ba69fbcbdd3bc5dc3e2&quot;&#125;,</span><br><span class="line">    &#123;file &#x3D; &quot;colorama-0.4.4.tar.gz&quot;, hash &#x3D; &quot;sha256:5941b2b48a20143d2267e95b1c2a7603ce057ee39fd88e7329b0c292aa16869b&quot;&#125;,</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>目前大部分编程语言的依赖管理工具都会自带和 <code>poetry.lock</code> 文件这样的版本锁机制，其目的在于能够将当前的依赖版本记录下来（这个过程主要由工具自动生成对应的校验内容），因而不论是在与别人协作、使用 CI/CD 工具甚至部署到生产环境时都 <strong>能确保所有使用的依赖版本及内容一致</strong>，进一步减少因环境不一致导致问题排查困难的问题。</p><p>虽然 Poetry 是一个不同于以往 venv、Virtualenv 以及 Conda 的新模式，并且到目前为止（截止至 2022 年 7 月 28 日）也已经演进到了 1.1.x 版本，但从 Github 项目仓库的 Issue 模块（笔者按：指与项目有关的问题反馈、功能要求、讨论的页面板块）未解决的数量来看，Poetry 依旧有着这样或那样的问题或小毛病，例如一直为人诟病的依赖解析时间过长的问题。</p><p>因此如果是在公司内部项目中，如果部门或小组本就有了被长期使用的工具，那么就最好不要与其他人背道而驰地使用 Poetry 来「标新立异」。但除此之外的情况，笔者却十分鼓励正在学习的读者去踊跃尝试 Poetry，毕竟个人往往都是在折腾中学习、成长。同时，Poetry 的命令并不算多，不论是学习还是使用的成本相对而言没有那么高，学习它也同样是为了与时俱进、拥抱未来。</p><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>Python 社区里各种虚拟环境与依赖管理的工具层出不穷也一直是为人所诟病的地方，并且和 Python 一样有着悠久历史的编程语言比如 JavaScript（Node.js）、Java 等也会面临同样的问题。因此像 Rust 这样后起之秀的编程语言，就积极吸取了以往的经验教训，在设计上会将环境、依赖管理等工具统一整合到一起。</p><p>除了本章所介绍的工具之外，在 Python 社区中还存在 <a href="https://sspai.com/link?target=https%3A%2F%2Fgithub.com%2Fpypa%2Fpipx">pipx</a>、<a href="https://sspai.com/link?target=https%3A%2F%2Fgithub.com%2Fpyenv%2Fpyenv">pyenv</a>、<a href="https://sspai.com/link?target=https%3A%2F%2Fpipenv.pypa.io%2Fen%2Flatest%2F">pipenv</a> 等等功能类似的工具，这也侧面反映出 Python 社区在依赖管理方案上群雄割据的混乱情况。</p><p>在 2018 年出现的 Python 增强提案 <a href="https://sspai.com/link?target=https%3A%2F%2Fpeps.python.org%2Fpep-0582%2F">PEP 582</a> 中又出现了一种和本文内容虚拟环境管理有所不同的一种依赖管理方式，使得 Python 项目再也不需要虚拟环境，而是在项目目录中存在一个名为 <code>__pypackages__</code> 的特殊文件夹即可直接使用相应的 Python 解释器执行代码；其模式类似于前端工具 <a href="https://sspai.com/link?target=https%3A%2F%2Fwww.npmjs.com%2F">npm</a> 的 <code>node_modules</code> 文件夹，会在每次添加依赖时自动在本地目录中下载依赖。</p><p>所以在 PEP 582 提案基础上又出现了类似于 <a href="https://sspai.com/link?target=https%3A%2F%2Fgithub.com%2Fpdm-project%2Fpdm">PDM</a> 的工具。</p><p>但不论这些工具如何的丰富，我们在对它们进行选择时，除了考虑场景之外，更多时候还主要是以稳定性为主。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;a href=&quot;https://sspai.com/post/75978&quot;&gt;https://sspai.com/post/75978&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最开始使用 Python 时，相信很多读者都会安装一个全局的（Global）Python 解释器，然后就用这唯</summary>
      
    
    
    
    <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
    <category term="python虚拟环境" scheme="http://yoursite.com/tags/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>weaviate</title>
    <link href="http://yoursite.com/2024/01/03/weaviate/"/>
    <id>http://yoursite.com/2024/01/03/weaviate/</id>
    <published>2024-01-03T07:48:26.000Z</published>
    <updated>2024-01-03T08:28:51.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据结构"><a class="markdownIt-Anchor" href="#1-数据结构"></a> 1、数据结构</h1><p>Weaviate 中的每个数据对象始终属于一个类，并且具有一个或多个属性。Weaviate 将<em>数据对象</em>（表示为 JSON 文档）存储在<em>基于类的集合</em>中，还可以将<code>vector</code>表示附加到数据对象上。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;779c8970-0594-301c-bff5-d12907414002&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;class&quot;</span>: <span class="string">&quot;Author&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Alice Munro&quot;</span>,</span><br><span class="line">        (...)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;vector&quot;: [</span><br><span class="line">        -0.16147631,</span><br><span class="line">        -0.065765485,</span><br><span class="line">        <span class="number">-0.06546908</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-交叉引用"><a class="markdownIt-Anchor" href="#11-交叉引用"></a> 1.1 交叉引用</h2><p>当数据对象彼此存在关系时，它们可以在 Weaviate 中通过交叉引用来表示。<strong>创建交叉引用不会影响任一方向的对象向量。</strong></p><p>例如：<em>Paul Krugman</em> 为 <em>The New York Times</em> 编辑。可以在<em>Author</em> 对象的writeFor 通过uuid 体现出交叉引用 <em>Publication</em> 。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Publication 对象</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;32d5a368-ace8-3bb7-ade7-9f7ff03eddb6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;class&quot;</span>: <span class="string">&quot;Publication&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;The New York Times&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;vector&quot;</span>: [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Author 对象，引用了uuid=&quot;32d5a368-ace8-3bb7-ade7-9f7ff03eddb6&quot;的Publication对象</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;779c8970-0594-301c-bff5-d12907414002&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;class&quot;</span>: <span class="string">&quot;Author&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Paul Krugman&quot;</span>,</span><br><span class="line">        ...</span><br><span class="line">        &quot;writesFor&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;beacon&quot;</span>: <span class="string">&quot;weaviate://localhost/32d5a368-ace8-3bb7-ade7-9f7ff03eddb6&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;/v1/objects/32d5a368-ace8-3bb7-ade7-9f7ff03eddb6&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;vector&quot;: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-schema"><a class="markdownIt-Anchor" href="#12-schema"></a> 1.2 Schema</h2><p>schema 又叫集合/类。即，类和属性的定义就是schema。每个类都有自己的向量空间，这意味着您可以将不同模型的向量附加到不同的类。可以通过设置交叉引用来链接类</p><h1 id="2-模块"><a class="markdownIt-Anchor" href="#2-模块"></a> 2、模块</h1><p>Weaviate 具有模块化结构。<em>矢量化或备份等功能由可选</em>模块处理。Weaviate 的core是一个纯矢量原生数据库，没有附加任何模块。如果选择不包含任何模块，则需要为每个数据条目输入一个向量。然后，您也可以通过向量搜索对象。</p><ul><li>矢量化和排名：矢量化模块（如<code>text2vec-*</code>、<code>multi2vec-*</code>或<code>img2vec-*</code>模块）将数据转换为向量。排名模块与<code>rerank-*</code>模块一样，对结果进行排名。</li><li>读取器或生成器模块：在矢量化器模块之上使用。这些模块获取检索到的一组相关文档，并执行其他操作，例如回答问题或生成任务。阅读器模块的一个示例是<a href="https://weaviate.io/developers/weaviate/modules/reader-generator-modules/qna-transformers"><code>qna-transformers</code></a>module，它直接从文档中提取答案。另一方面，生成器模块将使用<em>语言生成</em>从给定文档生成答案。</li><li>其他：gcs-backup<code>或 之类的内容</code>text-spellcheck</li></ul><h1 id="3-存储"><a class="markdownIt-Anchor" href="#3-存储"></a> 3、存储</h1><p>Weaviate 不依赖任何第三方数据库。分片的三个组件都位于 Weaviate 内。主要包含3个组件</p><ul><li>对象存储，一个KV数据库</li><li>倒排索引</li><li>向量索引（默认为HNSW）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数据结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-数据结构&quot;&gt;&lt;/a&gt; 1、数据结构&lt;/h1&gt;
&lt;p&gt;Weaviate 中的每个数据对象始终属于一个类，并且具有一个或多个属性。Weaviate 将&lt;em&gt;数据对象&lt;/em&gt;</summary>
      
    
    
    
    <category term="向量数据库" scheme="http://yoursite.com/categories/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="weaviate" scheme="http://yoursite.com/tags/weaviate/"/>
    
  </entry>
  
  <entry>
    <title>k8s的nebula</title>
    <link href="http://yoursite.com/2023/12/14/k8s%E7%9A%84nebula/"/>
    <id>http://yoursite.com/2023/12/14/k8s%E7%9A%84nebula/</id>
    <published>2023-12-14T12:52:48.000Z</published>
    <updated>2023-12-20T03:16:44.181Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 是通过operator安装的nebula</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自定义资源</span></span><br><span class="line">kubectl api-resources | grep nebula</span><br><span class="line">nebulaclusters                    nc           apps.nebula-graph.io           true         NebulaCluster</span><br><span class="line">nebularestores                    rt           apps.nebula-graph.io           true         NebulaRestore</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看资源类型配置文件</span></span><br><span class="line">kubectl get  nc -n kbstudio-prod -o yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看资源类型实例名称</span></span><br><span class="line">kubectl get nc -n kbstudio-prod</span><br><span class="line">NAME            AGE</span><br><span class="line">nebula-nebula   19d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看资源类型*实例*配置文件</span></span><br><span class="line">kubectl get nc nebula-nebula -n kbstudio-prod -o yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps.nebula-graph.io/v1alpha1</span><br><span class="line">kind: NebulaCluster</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2023-11-04T03:24:07Z&quot;</span><br><span class="line">  generation: 1</span><br><span class="line">  name: nebula-nebula</span><br><span class="line">  namespace: kbstudio-prod</span><br><span class="line">  resourceVersion: &quot;496942&quot;</span><br><span class="line">  selfLink: /apis/apps.nebula-graph.io/v1alpha1/namespaces/kbstudio-prod/nebulaclusters/nebula-nebula</span><br><span class="line">  uid: 9d245fbb-7ac1-11ee-ba43-005056a7b4ea</span><br><span class="line">spec:</span><br><span class="line">  enablePVReclaim: true</span><br><span class="line">  graphd:</span><br><span class="line">    affinity:</span><br><span class="line">      nodeAffinity:</span><br><span class="line">        requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          nodeSelectorTerms:</span><br><span class="line">          - matchExpressions:</span><br><span class="line">            - key: dop.dtdream.com/middleware.share</span><br><span class="line">              operator: Exists</span><br><span class="line">    config:</span><br><span class="line">      enable_authorize: &quot;true&quot;</span><br><span class="line">      minloglevel: &quot;1&quot;</span><br><span class="line">      redirect_stdout: &quot;false&quot;</span><br><span class="line">      stderrthreshold: &quot;0&quot;</span><br><span class="line">      timezone_name: UTC+08:00</span><br><span class="line">    env:</span><br><span class="line">    - name: GLOG_logtostderr</span><br><span class="line">      value: &quot;1&quot;</span><br><span class="line">    image: hub.dtwarebase.tech/dop/nebula-graphd</span><br><span class="line">    labels:</span><br><span class="line">      app: nebula-nebula</span><br><span class="line">      app.mw.dopware.tech/name: nebula</span><br><span class="line">      env.mw.dopware.tech/name: prod</span><br><span class="line">      instType: middleware</span><br><span class="line">      name: nebula-nebula-graphd</span><br><span class="line">      project.mw.dopware.tech/name: kbstudio</span><br><span class="line">      type.mw.dopware.tech/name: nebula</span><br><span class="line">    replicas: 3</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        memory: 6144Mi</span><br><span class="line">      requests:</span><br><span class="line">        memory: 3072Mi</span><br><span class="line">    version: v3.4.1</span><br><span class="line">  imagePullPolicy: Always</span><br><span class="line">  metad:</span><br><span class="line">    affinity:</span><br><span class="line">      nodeAffinity:</span><br><span class="line">        requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          nodeSelectorTerms:</span><br><span class="line">          - matchExpressions:</span><br><span class="line">            - key: dop.dtdream.com/middleware.share</span><br><span class="line">              operator: Exists</span><br><span class="line">    config:</span><br><span class="line">      minloglevel: &quot;1&quot;</span><br><span class="line">      redirect_stdout: &quot;false&quot;</span><br><span class="line">      stderrthreshold: &quot;0&quot;</span><br><span class="line">      timezone_name: UTC+08:00</span><br><span class="line">    dataVolumeClaim:</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 2Gi</span><br><span class="line">      storageClassName: nebula-local-storage</span><br><span class="line">    env:</span><br><span class="line">    - name: GLOG_logtostderr</span><br><span class="line">      value: &quot;1&quot;</span><br><span class="line">    image: hub.dtwarebase.tech/dop/nebula-metad</span><br><span class="line">    labels:</span><br><span class="line">      app: nebula-nebula</span><br><span class="line">      app.mw.dopware.tech/name: nebula</span><br><span class="line">      env.mw.dopware.tech/name: prod</span><br><span class="line">      instType: middleware</span><br><span class="line">      name: nebula-nebula-metad</span><br><span class="line">      project.mw.dopware.tech/name: kbstudio</span><br><span class="line">      type.mw.dopware.tech/name: nebula</span><br><span class="line">    replicas: 3</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        memory: 3072Mi</span><br><span class="line">      requests:</span><br><span class="line">        memory: 1536Mi</span><br><span class="line">    version: v3.4.1</span><br><span class="line">  nodeSelector:</span><br><span class="line">    dop.dtdream.com/hostgroup: default</span><br><span class="line">  reference:</span><br><span class="line">    name: statefulsets.apps</span><br><span class="line">    version: v1</span><br><span class="line">  schedulerName: default-scheduler</span><br><span class="line">  storaged:</span><br><span class="line">    affinity:</span><br><span class="line">      nodeAffinity:</span><br><span class="line">        requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          nodeSelectorTerms:</span><br><span class="line">          - matchExpressions:</span><br><span class="line">            - key: dop.dtdream.com/middleware.share</span><br><span class="line">              operator: Exists</span><br><span class="line">    config:</span><br><span class="line">      minloglevel: &quot;1&quot;</span><br><span class="line">      redirect_stdout: &quot;false&quot;</span><br><span class="line">      stderrthreshold: &quot;0&quot;</span><br><span class="line">      timezone_name: UTC+08:00</span><br><span class="line">    dataVolumeClaims:</span><br><span class="line">    - resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 2Gi</span><br><span class="line">      storageClassName: nebula-local-storage</span><br><span class="line">    enableAutoBalance: true</span><br><span class="line">    env:</span><br><span class="line">    - name: GLOG_logtostderr</span><br><span class="line">      value: &quot;1&quot;</span><br><span class="line">    image: hub.dtwarebase.tech/dop/nebula-storaged</span><br><span class="line">    labels:</span><br><span class="line">      app: nebula-nebula</span><br><span class="line">      app.mw.dopware.tech/name: nebula</span><br><span class="line">      env.mw.dopware.tech/name: prod</span><br><span class="line">      instType: middleware</span><br><span class="line">      name: nebula-nebula-storaged</span><br><span class="line">      project.mw.dopware.tech/name: kbstudio</span><br><span class="line">      type.mw.dopware.tech/name: nebula</span><br><span class="line">    replicas: 3</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        memory: 3072Mi</span><br><span class="line">      requests:</span><br><span class="line">        memory: 1536Mi</span><br><span class="line">    version: v3.4.1</span><br><span class="line">  unsatisfiableAction: ScheduleAnyway</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看存储卷</span></span><br><span class="line">kubectl get pv | grep nebula</span><br><span class="line">    pvc-kbstudio-prod-nebula-nebula-metad-0      50Gi       RWO            Delete           Bound    kbstudio-prod/metad-data-nebula-nebula-metad-0         nebula-local-storage             40d</span><br><span class="line">    pvc-kbstudio-prod-nebula-nebula-metad-1      50Gi       RWO            Delete           Bound    kbstudio-prod/metad-data-nebula-nebula-metad-1         nebula-local-storage             40d</span><br><span class="line">    pvc-kbstudio-prod-nebula-nebula-metad-2      50Gi       RWO            Delete           Bound    kbstudio-prod/metad-data-nebula-nebula-metad-2         nebula-local-storage             40d</span><br><span class="line">    pvc-kbstudio-prod-nebula-nebula-storaged-0   50Gi       RWO            Delete           Bound    kbstudio-prod/storaged-data-nebula-nebula-storaged-0   nebula-local-storage             40d</span><br><span class="line">    pvc-kbstudio-prod-nebula-nebula-storaged-1   50Gi       RWO            Delete           Bound    kbstudio-prod/storaged-data-nebula-nebula-storaged-1   nebula-local-storage             40d</span><br><span class="line">    pvc-kbstudio-prod-nebula-nebula-storaged-2   50Gi       RWO            Delete           Bound    kbstudio-prod/storaged-data-nebula-nebula-storaged-2   nebula-local-storage             40d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某一个存储</span></span><br><span class="line">[root@controller1 ~]# kubectl describe pv pvc-kbstudio-prod-nebula-nebula-storaged-0</span><br><span class="line">Name:              pvc-kbstudio-prod-nebula-nebula-storaged-0</span><br><span class="line">Labels:            app.kubernetes.io/cluster=nebula-nebula</span><br><span class="line">                   app.kubernetes.io/component=storaged</span><br><span class="line">                   app.kubernetes.io/managed-by=nebula-operator</span><br><span class="line">                   app.kubernetes.io/name=nebula-graph</span><br><span class="line">Annotations:       nebula-graph.io/pod-name: nebula-nebula-storaged-0</span><br><span class="line">Finalizers:        [kubernetes.io/pv-protection]</span><br><span class="line">StorageClass:      nebula-local-storage</span><br><span class="line">Status:            Bound</span><br><span class="line">Claim:             kbstudio-prod/storaged-data-nebula-nebula-storaged-0</span><br><span class="line">Reclaim Policy:    Delete</span><br><span class="line">Access Modes:      RWO</span><br><span class="line">VolumeMode:        Filesystem</span><br><span class="line">Capacity:          50Gi</span><br><span class="line">Node Affinity:</span><br><span class="line">  Required Terms:</span><br><span class="line">    Term 0:        kubernetes.io/hostname in [10.10.8.96]</span><br><span class="line">Message:</span><br><span class="line">Source:</span><br><span class="line">    Type:          HostPath (bare host directory volume)</span><br><span class="line">    Path:          /data/middleware/kbstudio/prod/nebula-nebula-storaged-0</span><br><span class="line">    HostPathType:</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="图数据库" scheme="http://yoursite.com/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="nebule" scheme="http://yoursite.com/tags/nebule/"/>
    
  </entry>
  
  <entry>
    <title>spark图计算以及优化</title>
    <link href="http://yoursite.com/2023/12/14/spark%E5%9B%BE%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2023/12/14/spark%E5%9B%BE%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</id>
    <published>2023-12-14T10:39:52.000Z</published>
    <updated>2023-12-14T10:52:47.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-中心性"><a class="markdownIt-Anchor" href="#1-中心性"></a> 1、中心性</h2><h3 id="11-度中心性"><a class="markdownIt-Anchor" href="#11-度中心性"></a> 1.1 度中心性</h3><p>​度中心性（Degree Centrality）：度中心性是指节点在网络中的度数，即与该节点直接相连的边的数量。度中心性越高，说明该节点在网络中的连接数越多，具有较高的影响力。应用场景包括社交网络分析、关键词提取等。节点的入边数量称为节点的入度（In-degree），出边数量则称为出度（Out-degree），如果忽略边的方向计算所有边的数量，就得到节点的度。</p><h3 id="12-接近中心性"><a class="markdownIt-Anchor" href="#12-接近中心性"></a> 1.2 接近中心性</h3><p>接近中心性（Closeness Centrality）：接近中心性是指节点到其他节点的平均距离的倒数。接近中心性越高，说明该节点与其他节点的联系越紧密，具有较高的传播能力。应用场景包括信息传播、疾病传播等。</p><p>接近中心性，即计算每个点到它可连通的其它各点的最短距离的平均值的倒数。计算公式：</p><p>其中，x 为待计算的目标节点，y 为通过边与 x 相连的任意一个节点（不包含x），k-1 为 y 的个数，d(x,y) 为 x 到 y 的最短距离。</p><p><strong>特殊说明：</strong> 孤立实体的接近中心性分值为 0。</p><h3 id="13-中介中心性"><a class="markdownIt-Anchor" href="#13-中介中心性"></a> 1.3 中介中心性</h3><p>中介中心性（Betweenness Centrality）：中介中心性是指节点在网络中作为中介的频率。中介节点在网络中的作用是连接不同的社区，促进信息传递和交流。中介中心性越高，说明该节点在信息传播中的作用越大。应用场景包括社交网络分析、交通网络分析等。</p><p>TIPS:中介中心性的取值范围是 0 到 1，节点的分值越大，对于网络流通性或连通性的影响力越大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-中心性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-中心性&quot;&gt;&lt;/a&gt; 1、中心性&lt;/h2&gt;
&lt;h3 id=&quot;11-度中心性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-度中心性&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="图计算" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>minikube</title>
    <link href="http://yoursite.com/2023/12/07/minikube/"/>
    <id>http://yoursite.com/2023/12/07/minikube/</id>
    <published>2023-12-07T07:42:44.000Z</published>
    <updated>2023-12-07T07:44:38.668Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhaowenyu.com/minikube-doc/">https://www.zhaowenyu.com/minikube-doc/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.zhaowenyu.com/minikube-doc/&quot;&gt;https://www.zhaowenyu.com/minikube-doc/&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="k8s" scheme="http://yoursite.com/categories/k8s/"/>
    
    
    <category term="minikube" scheme="http://yoursite.com/tags/minikube/"/>
    
  </entry>
  
  <entry>
    <title>spark优化手段</title>
    <link href="http://yoursite.com/2023/12/05/spark%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/"/>
    <id>http://yoursite.com/2023/12/05/spark%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/</id>
    <published>2023-12-05T08:43:39.000Z</published>
    <updated>2023-12-05T08:52:57.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-常用参数"><a class="markdownIt-Anchor" href="#一-常用参数"></a> 一、常用参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--driver-memory 4g : driver内存大小，一般没有广播变量(broadcast)时，设置4g足够，如果有广播变量，视情况而定，可设置6G，8G，12G等均可</span><br><span class="line"></span><br><span class="line">--executor-memory 4g : 每个executor的内存，正常情况下是4g足够，但有时处理大批量数据时容易内存不足，再多申请一点，如6G</span><br><span class="line"></span><br><span class="line">--num-executors 15 : 总共申请的executor数目，普通任务十几个或者几十个足够了，若是处理海量数据如百G上T的数据时可以申请多一些，100，200等</span><br><span class="line"></span><br><span class="line">--executor-cores 2  : 每个executor内的核数，即每个executor中的任务task数目，此处设置为2，即2个task共享上面设置的6g内存，每个map或reduce任务的并行度是executor数目*executor中的任务数</span><br><span class="line">yarn集群中一般有资源申请上限，如，executor-memory*num-executors &lt; 400G 等，所以调试参数时要注意这一点</span><br><span class="line"></span><br><span class="line">—-spark.default.parallelism 200 ： Spark作业的默认为500~1000个比较合适,如果不设置，spark会根据底层HDFS的block数量设置task的数量，这样会导致并行度偏少，资源利用不充分。该参数设为num-executors * executor-cores的2~3倍比较合适。</span><br><span class="line"></span><br><span class="line">-- spark.storage.memoryFraction 0.6 : 设置RDD持久化数据在Executor内存中能占的最大比例。默认值是0.6</span><br><span class="line"></span><br><span class="line">—-spark.shuffle.memoryFraction 0.2 ： 设置shuffle过程中一个task拉取到上个stage的task的输出后，进行聚合操作时能够使用的Executor内存的比例，默认是0.2，如果shuffle聚合时使用的内存超出了这个20%的限制，多余数据会被溢写到磁盘文件中去，降低shuffle性能</span><br><span class="line"></span><br><span class="line">—-spark.yarn.executor.memoryOverhead 1G ： executor执行的时候，用的内存可能会超过executor-memory，所以会为executor额外预留一部分内存，spark.yarn.executor.memoryOverhead即代表这部分内存</span><br></pre></td></tr></table></figure><h2 id="二-编程建议"><a class="markdownIt-Anchor" href="#二-编程建议"></a> 二、编程建议</h2><ol><li><p>避免创建重复的RDD，尽量复用同一份数据。</p></li><li><p>尽量避免使用shuffle类算子，因为shuffle操作是spark中最消耗性能的地方，reduceByKey、join、distinct、repartition等算子都会触发shuffle操作，尽量使用map类的非shuffle算子</p></li><li><p>用aggregateByKey和reduceByKey替代groupByKey,因为前两个是预聚合操作，会在每个节点本地对相同的key做聚合，等其他节点拉取所有节点上相同的key时，会大大减少磁盘IO以及网络开销。</p></li><li><p>repartition适用于RDD[V], partitionBy适用于RDD[K, V]</p></li><li><p>mapPartitions操作替代普通map，foreachPartitions替代foreach</p></li><li><p>filter操作之后进行coalesce操作，可以减少RDD的partition数量</p></li><li><p>如果有RDD复用，尤其是该RDD需要花费比较长的时间，建议对该RDD做cache，若该RDD每个partition需要消耗很多内存，建议开启Kryo序列化机制(据说可节省2到5倍空间),若还是有比较大的内存开销，可将storage_level设置为MEMORY_AND_DISK_SER</p></li><li><p>尽量避免在一个Transformation中处理所有的逻辑，尽量分解成map、filter之类的操作</p></li><li><p>多个RDD进行union操作时，避免使用rdd.union(rdd).union(rdd).union(rdd)这种多重union，rdd.union只适合2个RDD合并，合并多个时采用SparkContext.union(Array(RDD))，避免union嵌套层数太多，导致的调用链路太长，耗时太久，且容易引发StackOverFlow</p></li><li><p>spark中的Group/join/XXXByKey等操作，都可以指定partition的个数，不需要额外使用repartition和partitionBy函数</p></li><li><p>尽量保证每轮Stage里每个task处理的数据量&gt;128M</p></li><li><p>如果2个RDD做join，其中一个数据量很小，可以采用Broadcast Join，将小的RDD数据collect到driver内存中，将其BroadCast到另外以RDD中，其他场景想优化后面会讲</p></li><li><p>2个RDD做笛卡尔积时，把小的RDD作为参数传入，如BigRDD.certesian(smallRDD)</p></li><li><p>若需要Broadcast一个大的对象到远端作为字典查询，可使用多executor-cores，大executor-memory。若将该占用内存较大的对象存储到外部系统，executor-cores=1， executor-memory=m(默认值2g),可以正常运行，那么当大字典占用空间为size(g)时，executor-memory为2*size，executor-cores=size/m(向上取整)</p></li></ol><p>15.如果对象太大无法BroadCast到远端，且需求是根据大的RDD中的key去索引小RDD中的key，可使用zipPartitions以hash join的方式实现，具体原理参考下一节的shuffle过程</p><ol start="16"><li>如果需要在repartition重分区之后还要进行排序，可直接使用repartitionAndSortWithinPartitions，比分解操作效率高，因为它可以一边shuffle一边排序</li></ol><h2 id="三-shuffle-优化"><a class="markdownIt-Anchor" href="#三-shuffle-优化"></a> 三、shuffle 优化</h2><p><strong>3.1 什么是shuffle操作</strong></p><p>spark中的shuffle操作功能：将分布在集群中多个节点上的同一个key，拉取到同一个节点上，进行聚合或join操作，类似洗牌的操作。这些分布在各个存储节点上的数据重新打乱然后汇聚到不同节点的过程就是shuffle过程。</p><p><strong>3.2 哪些操作中包含shuffle操作</strong></p><p>RDD的特性是不可变的带分区的记录集合，Spark提供了Transformation和Action两种操作RDD的方式。Transformation是生成新的RDD，包括map, flatMap, filter, union, sample, join, groupByKey, cogroup, ReduceByKey, cros, sortByKey, mapValues等；Action只是返回一个结果，包括collect，reduce，count，save，lookupKey等</p><p>Spark所有的算子操作中是否使用shuffle过程要看计算后对应多少分区：</p><ul><li>若一个操作执行过程中，结果RDD的每个分区只依赖上一个RDD的同一个分区，即属于窄依赖，如map、filter、union等操作，这种情况是不需要进行shuffle的，同时还可以按照pipeline的方式，把一个分区上的多个操作放在同一个Task中进行</li><li>若结果RDD的每个分区需要依赖上一个RDD的全部分区，即属于宽依赖，如repartition相关操作（repartition，coalesce）、*ByKey操作（groupByKey，ReduceByKey，combineByKey、aggregateByKey等）、join相关操作（cogroup，join）、distinct操作，这种依赖是需要进行shuffle操作的</li></ul><p><strong>3.3 shuffle操作过程</strong></p><p>shuffle过程分为shuffle write和shuffle read两部分</p><ul><li>shuffle write： 分区数由上一阶段的RDD分区数控制，shuffle write过程主要是将计算的中间结果按某种规则临时放到各个executor所在的本地磁盘上（当前stage结束之后，每个task处理的数据按key进行分类，数据先写入内存缓冲区，缓冲区满，溢写spill到磁盘文件，最终相同key被写入同一个磁盘文件）创建的磁盘文件数量=当前stage中task数量*下一个stage的task数量</li><li>shuffle read：从上游stage的所有task节点上拉取属于自己的磁盘文件，每个read task会有自己的buffer缓冲，每次只能拉取与buffer缓冲相同大小的数据，然后聚合，聚合完一批后拉取下一批，边拉取边聚合。分区数由Spark提供的一些参数控制，如果这个参数值设置的很小，同时shuffle read的数据量很大，会导致一个task需要处理的数据非常大，容易发生JVM crash，从而导致shuffle数据失败，同时executor也丢失了，就会看到Failed to connect to host 的错误(即executor lost)。</li></ul><p>shuffle过程中，各个节点会通过shuffle write过程将相同key都会先写入本地磁盘文件中，然后其他节点的shuffle read过程通过网络传输拉取各个节点上的磁盘文件中的相同key。这其中大量数据交换涉及到的网络传输和文件读写操作是shuffle操作十分耗时的根本原因</p><p><strong>3.4 spark的shuffle类型</strong></p><p>参数spark.shuffle.manager用于设置ShuffleManager的类型。Spark1.5以后，该参数有三个可选项：hash、sort和tungsten-sort。HashShuffleManager是Spark1.2以前的默认值，Spark1.2之后的默认值都是SortShuffleManager。tungsten-sort与sort类似，但是使用了tungsten计划中的堆外内存管理机制，内存使用效率更高。</p><p>由于SortShuffleManager默认会对数据进行排序，因此如果业务需求中需要排序的话，使用默认的SortShuffleManager就可以；但如果不需要排序，可以通过bypass机制或设置HashShuffleManager避免排序，同时也能提供较好的磁盘读写性能。</p><p>HashShuffleManager流程：</p><p><img src="/2023/12/05/spark%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/.%5Cimage-20231205164908044.png" alt="image-20231205164908044"></p><p>SortShuffleManager流程：</p><p><img src="/2023/12/05/spark%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/.%5Cimage-20231205165009636.png" alt="image-20231205165009636"></p><p><strong>3.5 如何开启bypass机制</strong></p><p>bypass机制通过参数spark.shuffle.sort.bypassMergeThreshold设置，默认值是200，表示当ShuffleManager是SortShuffleManager时，若shuffle read task的数量小于这个阈值（默认200）时，则shuffle write过程中不会进行排序操作，而是直接按照未经优化的HashShuffleManager的方式写数据，但最后会将每个task产生的所有临时磁盘文件合并成一个文件，并创建索引文件。</p><p>这里给出的调优建议是，当使用SortShuffleManager时，如果的确不需要排序，可以将这个参数值调大一些，大于shuffle read task的数量。那么此时就会自动开启bypass机制，map-side就不会进行排序了，减少排序的性能开销，提升shuffle操作效率。但这种方式并没有减少shuffle write过程产生的磁盘文件数量，所以写的性能没有改变。</p><p><strong>3.6 HashShuffleManager优化建议</strong></p><p>如果使用HashShuffleManager，可以设置spark.shuffle.consolidateFiles参数。该参数默认为false，只有当使用HashShuffleManager且该参数设置为True时，才会开启consolidate机制，大幅度合并shuffle write过程产生的输出文件，对于shuffle read task 数量特别多的情况下，可以极大地减少磁盘IO开销，提升shuffle性能。参考社区同学给出的数据，consolidate性能比开启bypass机制的SortShuffleManager高出10% ~ 30%。</p><p><strong>3.7 shuffle调优建议</strong></p><p>除了上述的几个参数调优，shuffle过程还有一些参数可以提高性能：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- spark.shuffle.file.buffer : 默认32M，shuffle Write阶段写文件时的buffer大小，若内存资源比较充足，可适当将其值调大一些（如64M），减少executor的IO读写次数，提高shuffle性能</span><br><span class="line"></span><br><span class="line">- spark.shuffle.io.maxRetries ： 默认3次，Shuffle Read阶段取数据的重试次数，若shuffle处理的数据量很大，可适当将该参数调大。</span><br></pre></td></tr></table></figure><p><strong>3.8 shuffle操作过程中的常见错误</strong></p><p>SparkSQL中的shuffle错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.spark.shuffle.MetadataFetchFailedException: Missing an output location for shuffle 0</span><br><span class="line"></span><br><span class="line">org.apache.spark.shuffle.FetchFailedException:Failed to connect to hostname/192.168.xx.xxx:50268</span><br></pre></td></tr></table></figure><p>RDD中的shuffle错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARN TaskSetManager: Lost task 17.1 in stage 4.1 (TID 1386, spark050013): java.io.FileNotFoundException: /data04/spark/tmp/blockmgr-817d372f-c359-4a00-96dd-8f6554aa19cd/2f/temp_shuffle_e22e013a-5392-4edb-9874-a196a1dad97c (没有那个文件或目录)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FetchFailed(BlockManagerId(6083b277-119a-49e8-8a49-3539690a2a3f-S155, spark050013, 8533), shuffleId=1, mapId=143, reduceId=3, message=</span><br><span class="line">org.apache.spark.shuffle.FetchFailedException: Error in opening FileSegmentManagedBuffer&#123;file=/data04/spark/tmp/blockmgr-817d372f-c359-4a00-96dd-8f6554aa19cd/0e/shuffle_1_143_0.data, offset=997061, length=112503&#125;</span><br></pre></td></tr></table></figure><p>处理shuffle类操作的注意事项：</p><ul><li>减少shuffle数据量：在shuffle前过滤掉不必要的数据，只选取需要的字段处理</li><li>针对SparkSQL和DataFrame的join、group by等操作：可以通过 spark.sql.shuffle.partitions控制分区数，默认设置为200，可根据shuffle的量以及计算的复杂度提高这个值，如2000等</li><li>RDD的join、group by、reduceByKey等操作：通过spark.default.parallelism控制shuffle read与reduce处理的分区数，默认为运行任务的core总数，官方建议为设置成运行任务的core的2~3倍</li><li>提高executor的内存：即spark.executor.memory的值</li><li>分析数据验证是否存在数据倾斜的问题：如空值如何处理，异常数据（某个key对应的数据量特别大）时是否可以单独处理，可以考虑自定义数据分区规则，如何自定义可以参考下面的join优化环节</li></ul><h2 id="四-join性能优化"><a class="markdownIt-Anchor" href="#四-join性能优化"></a> 四、join性能优化</h2><p>Spark所有的操作中，join操作是最复杂、代价最大的操作，也是大部分业务场景的性能瓶颈所在。所以针对join操作的优化是使用spark必须要学会的技能。</p><p>spark的join操作也分为Spark SQL的join和Spark RDD的join。</p><p><strong>4.1 Spark SQL 的join操作</strong></p><p>4.1.1 Hash Join</p><p>Hash Join的执行方式是先将小表映射成Hash Table的方式，再将大表使用相同方式映射到Hash Table，在同一个hash分区内做join匹配。</p><p>hash join又分为broadcast hash join和shuffle hash join两种。其中Broadcast hash join，顾名思义，就是把小表广播到每一个节点上的内存中，大表按Key保存到各个分区中，小表和每个分区的大表做join匹配。这种情况适合一个小表和一个大表做join且小表能够在内存中保存的情况。如下图所示：</p><p><img src="/2023/12/05/spark%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/.%5Cimage-20231205165141779.png" alt="image-20231205165141779"></p><p>当Hash Join不能适用的场景就需要Shuffle Hash Join了，Shuffle Hash Join的原理是按照join Key分区，key相同的数据必然分配到同一分区中，将大表join分而治之，变成小表的join，可以提高并行度。执行过程也分为两个阶段：</p><ul><li>shuffle阶段：分别将两个表按照join key进行分区，将相同的join key数据重分区到同一节点</li><li>hash join阶段：每个分区节点上的数据单独执行单机hash join算法</li></ul><p>Shuffle Hash Join的过程如下图所示：</p><p><img src="/2023/12/05/spark%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/.%5Cimage-20231205165207770.png" alt="image-20231205165207770"></p><p>4.1.2 Sort-Merge Join</p><p>SparkSQL针对两张大表join的情况提供了全新的算法——Sort-merge join，整个过程分为三个步骤：</p><ul><li>Shuffle阶段：将两张大表根据join key进行重新分区，两张表数据会分布到整个集群，以便分布式进行处理</li><li>sort阶段：对单个分区节点的两表数据，分别进行排序</li><li>merge阶段：对排好序的两张分区表数据执行join操作。分别遍历两个有序序列，遇到相同的join key就merge输出，否则继续取更小一边的key，即合并两个有序列表的方式。</li></ul><p>sort-merge join流程如下图所示。</p><p><img src="/2023/12/05/spark%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/.%5Cimage-20231205165234232.png" alt="image-20231205165234232"></p><p><strong>4.2 Spark RDD的join操作</strong></p><p>Spark的RDD join没有上面这么多的分类，但是面临的业务需求是一样的。如果是大表join小表的情况，则可以将小表声明为broadcast变量，使用map操作快速实现join功能，但又不必执行Spark core中的join操作。</p><p>如果是两个大表join，则必须依赖Spark Core中的join操作了。Spark RDD Join的过程可以自行阅读源码了解，这里只做一个大概的讲解。</p><p>spark的join过程中最核心的函数是cogroup方法，这个方法中会判断join的两个RDD所使用的partitioner是否一样，如果分区相同，即存在OneToOneDependency依赖，不用进行hash分区，可直接join；如果要关联的RDD和当前RDD的分区不一致时，就要对RDD进行重新hash分区，分到正确的分区中，即存在ShuffleDependency，需要先进行shuffle操作再join。因此提升join效率的一个思路就是使得两个RDD具有相同的partitioners。</p><p>所以针对Spark RDD的join操作的优化建议是：</p><ul><li>如果需要join的其中一个RDD比较小，可以直接将其存入内存，使用broadcast hash join</li><li>在对两个RDD进行join操作之前，使其使用同一个partitioners，避免join操作的shuffle过程</li><li>如果两个RDD其一存在重复的key也会导致join操作性能变低，因此最好先进行key值的去重处理</li></ul><p><strong>4.3 数据倾斜优化</strong></p><p>均匀数据分布的情况下，前面所说的优化建议就足够了。但存在数据倾斜时，仍然会有性能问题。主要体现在绝大多数task执行得都非常快，个别task执行很慢，拖慢整个任务的执行进程，甚至可能因为某个task处理的数据量过大而爆出OOM错误。</p><p>shuffle操作中需要将各个节点上相同的key拉取到某一个节点上的一个task处理，如果某个key对应的数据量特别大，就会发生数据倾斜。</p><p>4.3.1 分析数据分布</p><p>如果是Spark SQL中的group by、join语句导致的数据倾斜，可以使用SQL分析执行SQL中的表的key分布情况；如果是Spark RDD执行shuffle算子导致的数据倾斜，可以在Spark作业中加入分析Key分布的代码，使用countByKey()统计各个key对应的记录数。</p><p>4.3.2 数据倾斜的解决方案</p><p>这里参考美团技术博客中给出的几个方案。</p><p>1）针对hive表中的数据倾斜，可以尝试通过hive进行数据预处理，如按照key进行聚合，或是和其他表join，Spark作业中直接使用预处理后的数据。</p><p>2）如果发现导致倾斜的key就几个，而且对计算本身的影响不大，可以考虑过滤掉少数导致倾斜的key</p><p>3）设置参数spark.sql.shuffle.partitions，提高shuffle操作的并行度，增加shuffle read task的数量，降低每个task处理的数据量</p><p>4）针对RDD执行reduceByKey等聚合类算子或是在Spark SQL中使用group by语句时，可以考虑两阶段聚合方案，即局部聚合+全局聚合。第一阶段局部聚合，先给每个key打上一个随机数，接着对打上随机数的数据执行reduceByKey等聚合操作，然后将各个key的前缀去掉。第二阶段全局聚合即正常的聚合操作。</p><p>5）针对两个数据量都比较大的RDD/hive表进行join的情况，如果其中一个RDD/hive表的少数key对应的数据量过大，另一个比较均匀时，可以先分析数据，将数据量过大的几个key统计并拆分出来形成一个单独的RDD，得到的两个RDD/hive表分别和另一个RDD/hive表做join，其中key对应数据量较大的那个要进行key值随机数打散处理，另一个无数据倾斜的RDD/hive表要1对n膨胀扩容n倍，确保随机化后key值仍然有效。</p><p>6）针对join操作的RDD中有大量的key导致数据倾斜，对有数据倾斜的整个RDD的key值做随机打散处理，对另一个正常的RDD进行1对n膨胀扩容，每条数据都依次打上0~n的前缀。处理完后再执行join操作</p><h2 id="五-其他错误总结"><a class="markdownIt-Anchor" href="#五-其他错误总结"></a> 五、其他错误总结</h2><p>(1) 报错信息</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemory, unable to create new native thread </span><br><span class="line">Caused by: java.lang.OutOfMemoryError: unable to create new native thread </span><br><span class="line">        at java.lang.Thread.start0(Native Method) </span><br><span class="line">        at java.lang.Thread.start(Thread.java:640) </span><br></pre></td></tr></table></figure><p>解决方案：</p><p>上面这段错误提示的本质是Linux操作系统无法创建更多进程，导致出错，并不是系统的内存不足。因此要解决这个问题需要修改Linux允许创建更多的进程，就需要修改Linux最大进程数</p><p>（2）报错信息</p><p>由于Spark在计算的时候会将中间结果存储到/tmp目录，而目前linux又都支持tmpfs，其实就是将/tmp目录挂载到内存当中, 那么这里就存在一个问题，中间结果过多导致/tmp目录写满而出现如下错误<br>No Space Left on the device（Shuffle临时文件过多）</p><p>解决方案：</p><p><a href="http://xn--spark-env-477nh9f666h82an66xy9tc.sh">修改配置文件spark-env.sh</a>,把临时文件引入到一个自定义的目录中去, 即:</p><p>export SPARK_LOCAL_DIRS=/home/utoken/datadir/spark/tmp</p><p>（3）报错信息</p><p>Worker节点中的work目录占用许多磁盘空间, 这些是Driver上传到worker的文件, 会占用许多磁盘空间</p><p>解决方案：</p><p>需要定时做手工清理work目录</p><p>（4）spark-shell提交Spark Application如何解决依赖库</p><p>解决方案：</p><p>利用–driver-class-path选项来指定所依赖的jar文件，注意的是–driver-class-path后如果需要跟着多个jar文件的话，jar文件之间使用冒号:来分割。</p><p>（5）内存不足或数据倾斜导致Executor Lost，shuffle fetch失败，Task重试失败等（spark-submit提交）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TaskSetManager: Lost task 1.0 in stage 6.0 (TID 100, 192.168.10.37): java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">INFO BlockManagerInfo: Added broadcast_8_piece0 in memory on 192.168.10.37:57139 (size: 42.0 KB, free: 24.2 MB)</span><br><span class="line">INFO BlockManagerInfo: Added broadcast_8_piece0 in memory on 192.168.10.38:53816 (size: 42.0 KB, free: 24.2 MB)</span><br><span class="line">INFO TaskSetManager: Starting task 3.0 in stage 6.0 (TID 102, 192.168.10.37, ANY, 2152 bytes)</span><br></pre></td></tr></table></figure><p>解决方案：</p><p>增加worker内存，或者相同资源下增加partition数目，这样每个task要处理的数据变少，占用内存变少</p><p>如果存在shuffle过程，设置shuffle read阶段的并行数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-常用参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-常用参数&quot;&gt;&lt;/a&gt; 一、常用参数&lt;/h2&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="spark" scheme="http://yoursite.com/categories/spark/"/>
    
    
    <category term="spark性能优化" scheme="http://yoursite.com/tags/spark%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2023/10/31/M11/"/>
    <id>http://yoursite.com/2023/10/31/M11/</id>
    <published>2023-10-31T06:46:55.434Z</published>
    <updated>2023-10-31T06:46:55.434Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>kettle插件开发</title>
    <link href="http://yoursite.com/2023/10/30/kettle%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2023/10/30/kettle%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2023-10-30T08:15:20.000Z</published>
    <updated>2023-10-31T10:33:07.895Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://help.hitachivantara.com/Documentation/Pentaho/Data_Integration_and_Analytics/9.5/Developer_center/Create_step_plugins">https://help.hitachivantara.com/Documentation/Pentaho/Data_Integration_and_Analytics/9.5/Developer_center/Create_step_plugins</a></p><h2 id="1-kettle-step插件开发接口"><a class="markdownIt-Anchor" href="#1-kettle-step插件开发接口"></a> 1、Kettle step插件开发接口</h2><table><thead><tr><th><strong>接口</strong></th><th><strong>基类</strong></th><th><strong>主要功能</strong></th></tr></thead><tbody><tr><td><strong>StepMetaInterface</strong></td><td>BaseStepMeta</td><td>存储step设置信息<br>验证step设置信息<br>序列化step设置信息<br>提供获取step类的方法</td></tr><tr><td><strong>StepDialogInterface</strong></td><td>BaseStepDialog</td><td>step属性信息配置窗口</td></tr><tr><td><strong>StepInterface</strong></td><td>BaseStep</td><td>处理rows</td></tr><tr><td><strong>StepDataInterface</strong></td><td>BaseStepData</td><td>为数据处理提高数据存储</td></tr></tbody></table><h2 id="2-kettle中相关类的命名规则"><a class="markdownIt-Anchor" href="#2-kettle中相关类的命名规则"></a> 2、kettle中相关类的命名规则</h2><ul><li>StepInterface的实现类以插件的功能相关命名：<code>*.java</code></li><li>StepDataInterface的实现类：<code>xxData.java</code></li><li>*StepMetaInterface的实现类：<code>xxMeta.java</code></li><li>StepDialogInterface的实现类：<code>xxDialog.java</code></li></ul><h2 id="3-转换执行过程"><a class="markdownIt-Anchor" href="#3-转换执行过程"></a> 3、转换执行过程</h2><blockquote><p>根据ktr文件执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KettleEnvironment.init();</span><br><span class="line">TransMeta transMeta = <span class="keyword">new</span> TransMeta(<span class="string">&quot;etl/capturing_rows.ktr&quot;</span>);</span><br><span class="line">Trans trans = <span class="keyword">new</span> Trans(transMeta);</span><br><span class="line">trans.prepareExecution(<span class="keyword">null</span>);</span><br><span class="line">trans.startThreads();<span class="comment">//执行该方法的时候，将会调用proccessRow()方法对每一行进行操作    </span></span><br><span class="line">trans.waitUntilFinished();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://help.hitachivantara.com/Documentation/Pentaho/Data_Integration_and_Analytics/9.5/Developer_center/Create_step_plugins&quot;&gt;h</summary>
      
    
    
    
    <category term="kettle" scheme="http://yoursite.com/categories/kettle/"/>
    
    
    <category term="插件" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>kettle</title>
    <link href="http://yoursite.com/2023/10/17/kettle/"/>
    <id>http://yoursite.com/2023/10/17/kettle/</id>
    <published>2023-10-17T01:22:06.000Z</published>
    <updated>2023-10-17T01:27:45.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-kettle简介"><a class="markdownIt-Anchor" href="#一-kettle简介"></a> 一、Kettle简介</h1><ul><li>Kettle最早是一个开源的ETL（Extract-Transform-Load的缩写）工具，全称为KDE Extraction, Transportation, Transformation and Loading Environment。后来Kettle重命名为<strong>Pentaho Data Integration</strong> 。</li><li>它由Java开发，支持跨平台运行，其特性包括：支持100%无编码、拖拽方式开发ETL数据管道；可对接包括传统数据库、文件、大数据平台、接口、流数据等数据源；支持ETL数据管道加入机器学习算法。</li><li>Kettle是一个实现ETL开发的一款开发工具，Spoon是Kettle工具提供的图形化界面。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-kettle简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-kettle简介&quot;&gt;&lt;/a&gt; 一、Kettle简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Kettle最早是一个开源的ETL（Extract-Transform-Load的缩</summary>
      
    
    
    
    <category term="ETL" scheme="http://yoursite.com/categories/ETL/"/>
    
    
    <category term="ETL" scheme="http://yoursite.com/tags/ETL/"/>
    
  </entry>
  
  <entry>
    <title>向量余弦相似度</title>
    <link href="http://yoursite.com/2023/10/11/%E5%90%91%E9%87%8F%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    <id>http://yoursite.com/2023/10/11/%E5%90%91%E9%87%8F%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/</id>
    <published>2023-10-11T12:42:12.000Z</published>
    <updated>2023-10-11T12:49:52.455Z</updated>
    
    <content type="html"><![CDATA[<p>假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦</p><p><img src="https://images.cnblogs.com/cnblogs_com/live41/cosA_1.png" alt="img"></p><p>2个向量之间的余弦公式：</p><p><img src="https://images.cnblogs.com/cnblogs_com/live41/cosTheta.png" alt="img"></p><p><img src="/2023/10/11/%E5%90%91%E9%87%8F%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/C:%5CUsers%5Ch2484%5CDesktop%5Cblog%5Cblog%5Csource_posts%5Cimage-20231011204603851.png" alt="image-20231011204603851"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec1.toArray.zip(vec2.toArray).map(d =&gt; d._1 * d._2).sum /</span><br><span class="line">(math.sqrt(vec1.toArray.map(d =&gt; d * d).sum) * math.sqrt(vec2.toArray.map(d =&gt; d * d).sum))</span><br></pre></td></tr></table></figure><p>使用Scala语言实现的向量操作，计算两个向量的余弦相似度。</p><ol><li><p><code>vec1.toArray</code> 和 <code>vec2.toArray</code> 将向量 <code>vec1</code> 和 <code>vec2</code> 转换为数组，方便对数组进行操作。</p></li><li><p><code>zip</code> 函数将两个数组中的对应元素配对为元组。例如，如果 <code>vec1</code> 是 <code>[a, b, c]</code>，而 <code>vec2</code> 是 <code>[x, y, z]</code>，<code>zip</code> 会生成 <code>[(a, x), (b, y), (c, z)]</code>。</p></li><li><p><code>map</code> 函数对每个元组中的元素执行操作。在这里，对每对元素执行乘法操作，即 <code>d._1 * d._2</code>，这会生成一个新数组，包含了对应位置元素的乘积。</p></li><li><p><code>sum</code> 函数对新生成的数组中的所有元素求和。</p></li><li><p>接下来，计算向量 <code>vec1</code> 和 <code>vec2</code> 的模（即长度）的乘积。模的计算通过将向量中每个元素的平方求和，然后再取平方根实现。</p></li><li><p>最后，计算余弦相似度的分子（两向量对应元素的乘积之和）除以余弦相似度的分母（向量模的乘积）。</p></li></ol><p>余弦相似度（Cosine Similarity）是衡量两个非零向量方向上的相似度的一种常用方法。在这个实现中，通过计算两个向量对应位置元素的乘积之和，除以两个向量模的乘积，来得到余弦相似度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/live41/cosA_1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>知识图谱推理</title>
    <link href="http://yoursite.com/2023/09/20/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86/"/>
    <id>http://yoursite.com/2023/09/20/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86/</id>
    <published>2023-09-20T01:02:06.000Z</published>
    <updated>2023-09-22T08:08:16.267Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/xiaoqi/tag/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">https://www.cnblogs.com/xiaoqi/tag/知识图谱/</a></p><p><a href="https://yubincloud.github.io/notebook/pages/4f4fc0/">https://yubincloud.github.io/notebook/pages/4f4fc0/</a></p><p><a href="https://qianshuang.github.io/2018/10/06/KB_02/">https://qianshuang.github.io/2018/10/06/KB_02/</a></p><p><a href="https://bbs.huaweicloud.com/blogs/286074">https://bbs.huaweicloud.com/blogs/286074</a></p><p><a href="https://developer.aliyun.com/article/1152527">https://developer.aliyun.com/article/1152527</a></p><h2 id="1-推理基础任务"><a class="markdownIt-Anchor" href="#1-推理基础任务"></a> 1、推理基础任务</h2><p>知识推理的几个基础任务主要包括知识补全、知识纠错、推理问答等。</p><ul><li>知识补全，即通过算法，补全知识图谱中缺失的属性或者关系。实际构建的知识图谱，通常存在不完备的问题，即部分关系或属性会缺失。</li><li>知识图谱的纠错，即发现图谱中的错误知识进行修正。例如，实际构建的知识图谱还可能存在错误知识。实体的类型、实体间的关系、实体属性值均可能存在错误。</li><li>基于知识图谱的推理问答，即KBQA，通常应用于涉及多个实体，多个关系，多跳，比较等相对复杂的问答任务。</li></ul><p><strong>1）知识推理任务示例</strong></p><p>如上图所示，以“姚沁蕾的妈妈是谁“为例。有一条常识是 “父亲的妻子是妈妈”，则可依据该常识，推理出姚沁蕾的妈妈是叶莉，进而补全”姚沁蕾”和“叶莉”之间的关系，提升知识图谱的完备性。</p><p><strong>2）知识纠错任务示例</strong></p><p>如上图所示，在某个影视知识图谱中，虚线框中的实体《春光灿烂猪八戒》，其类型为“电影“。它的属性有集数，主题曲、片尾曲等。而其他同为”电影“类别的实体，其属性多包含上映时期、票房，且大多没有集数这个属性。则推理可知，《春光灿烂猪八戒》这个实体的类型大概率存在错误，其正确类型应该是电视剧。</p><p><strong>3）推理问答任务示例</strong></p><p>如上图所示，面对“刘德华主演的电影中豆瓣评分大于8分的有哪些？“这样的问题，需要机器对该问题进行解析、理解，在知识图谱中完成查询、推理、比较动作，找到《天下无贼》和《无间道》作为答案返回。</p><h2 id="2-属性图和rdf图"><a class="markdownIt-Anchor" href="#2-属性图和rdf图"></a> 2、属性图和RDF图</h2><p>（1），市面上已知支持RDF推理功能的实现框架，比如，Jena，打开推理引擎后，查询速度极慢，同时由于推理引擎需要将数据全量载入内存，因此，只支持小数据集上图谱推理，性能有瓶颈，并且还需要做一整套的工具链，成本较高。</p><p>（2），出于各方面成本的考虑，虽然RDF模型语义完备，支持推理，解放了思想，但随之带来的高度复杂性却增加了成本，这也是大家常说学术界使用RDF模型，工业界都在讲属性图模型的原因。</p><p><img src="/2023/09/20/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86/C:%5CUsers%5Ch2484%5CDesktop%5Cblog%5Cblog%5Csource_posts%5Cimage-20230921181605741.png" alt="image-20230921181605741"></p><h2 id="3-演绎推理"><a class="markdownIt-Anchor" href="#3-演绎推理"></a> 3、演绎推理</h2><p>演绎推理的过程需要明确定义的先验信息，所以基于演绎的知识图谱推理多围绕本体展开。一般都是学术界使用居多。</p><ul><li>本体推理：OWL</li><li>逻辑编程推理：Datalog、OWL、ABox、TBox</li></ul><p><img src="/2023/09/20/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86/C:%5CUsers%5Ch2484%5CDesktop%5Cblog%5Cblog%5Csource_posts%5Cimage-20230922105733520.png" alt="image-20230922105733520"></p><ul><li>查询重写：基于查询重写的推理机有多个，例如 Ontop ① 、 Mastro ② 、Stardog③ 、Ultrawrap ④ 、 Morph</li></ul><p><img src="/2023/09/20/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86/C:%5CUsers%5Ch2484%5CDesktop%5Cblog%5Cblog%5Csource_posts%5Cimage-20230922105830784.png" alt="image-20230922105830784"></p><ul><li>产生式规则：一个产生式系统由事实集合、产生式集合和推理引擎三部分组成。</li></ul><p><img src="/2023/09/20/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86/C:%5CUsers%5Ch2484%5CDesktop%5Cblog%5Cblog%5Csource_posts%5Cimage-20230922105924508.png" alt="image-20230922105924508"></p><h2 id="4-归纳推理"><a class="markdownIt-Anchor" href="#4-归纳推理"></a> 4、归纳推理</h2><p>基于归纳的知识图谱推理主要是通过对知识图谱已有信息的分析和挖掘进行推理的， 最常用的信息为已有的三元组。按照推理要素的不同，基于归纳的知识图谱推理可以分为 以下几类：</p><ul><li><p>基于图结构的推理</p><blockquote><p><a href="https://github.com/noon99jaki/pra">https://github.com/noon99jaki/pra</a></p></blockquote></li></ul><p>PRA（Path Ranking Algorithm）利用了实体节点之 间的路径当作特征从而进行链接预测推理。它有两个任务</p><ul><li>给定关系𝑟和头实体h预测可能的尾实体𝑡是什么，即在给定h, 𝑟的情 况下，预测哪个三元组(h, 𝑟,𝑡)成立的可能性比较大，叫作尾实体链接预测。</li><li>另一个是在给 定𝑟,𝑡的情况下，预测可能的头实体h是什么，叫作头实体链接预测</li></ul><p>PRA 针对的知识图谱主要是自底向上自动化构建的含有较多噪声的图谱，例如 NELL，并将关系推理的问题形式化为一个排序问题，对每个关系的头实体预测和尾实体 预测都单独训练一条排序模型。PRA 将存在于知识图谱中的路径当作特征，并通过图上 的计算对每个路径赋予相应的特征值，然后利用这些特征学习一个逻辑斯蒂回归分类器完 成关系推理。在 PRA 中，每一个路径可以当作对当前关系判断的一个专家，不同的路径 从不同的角度说明了当前关系的存在与否。</p><ul><li>基于规则学习的推理</li></ul><p>基于规则的推理具有精确且可解释的特性，规则在学术界和工业界的推理场景都有重 要的应用。规则是基于规则推理的核心，所以规则获取是一个重要的任务。在小型的领域 知识图谱上，规则可以由领域专家提供，但在大型、综合的知识图谱方面，人工提供规则 的效率比较低，且很难做到全面和准确。所以，自动化的规则学习方法应运而生，旨在快 速有效地从大规模知识图谱上学习置信度较高的规则，并服务于关系推理任务。</p><p>首先介绍典型的规则学习方法 AMIE。<a href="http://www.mpi-inf.mpg.de/departments/ontologies/">http://www.mpi-inf.mpg.de/departments/ontologies/</a> projects/amie</p><p>基于关联规则挖掘⽅法(AMIE) 在不同数据集上的运行效果，从中可以看出 AMIE 在大规模知 识图谱上的效率较高。例如，在拥有 100 多万个实体以及近 700 万个三元组的 DBpedia 上，AMIE 仅需不到 3min 就能完成规则挖掘，产生 7000 条规则,并帮助推理出了 12 万 多个新的三元组。</p><p>AMIE 能挖掘的规则形如： father Of(𝑓, 𝑐) ← motherOf(𝑚, 𝑐) ∧ marriedTo(𝑚, 𝑓). AMIE 是一种霍恩规则，也是一种闭环规则，即整条规则可以在图中构成一个闭环结 构。在规则学习的任务中，最重要的是如何有效搜索空间，因为在大型的知识图谱上简单 地遍历所有可能的规则并评估规则的质量效率很低，几乎不可行。AMIE 定义了 3 个挖掘 算子（Mining Operators），通过不断在规则中增加挖掘算子来探索图上的搜索空间，并且 融入了对应的剪枝策略。3 个挖掘算子如下：  增加悬挂原子（Adding Dangling Atom）。即在规则中增加一个原子，这个原子包 含一个新的变量和一个已经在规则中出现的元素，可以是出现过的变量，也可以 是出现过的实体。  增加实例化的原子（Adding Instantiated Atom）。即在规则中增加一个原子，这个 原子包含一个实例化的实体以及一个已经在规则中出现的元素。 增加闭合原子（Adding Closing Atom）。即在规则中增加一个原子，这个原子包 含的两个元素都是已经出现在规则中的变量或实体。增加闭合原子之后，规则就 算构建完成了。</p><ul><li>基于表示学习的推理。</li></ul><p>基于图结构的推理和基于规则学习的推理，都<strong>显式</strong>地定义了推理学习所需的特征，而 基于表示学习的推理通过将知识图谱中包括实体和关系的元素映射到一个连续的向量空间 中，为每个元素学习在向量空间中表示，向量空间中的表示可以是一个或多个向量或矩 阵。表示学习让算法在学习向量表示的过程中自动捕捉、推理所需的特征，通过训练学 习，将知识图谱中离散符号表示的信息编码在不同的向量空间表示中，使得知识图谱的推 理能够通过预设的向量空间表示之间的计算自动实现，不需要显式的推理步骤。</p><p>知识图谱的表示学习受自然语言处理关于词向量研究的启发，因为在 word2vec 的结 果中发现了一些词向量具有空间平移性，例如： vec(king) − vec(queen) ≈ vec(man) − vec(woman) 即“king”的词向量减去“queen”的词向量的结果约等于“man”的词向量减去 “woman”的词向量的结果，这说明“king”和“queen”在语义上的关系与“man”和 “woman”之间的关系比较近似。而拓展到知识图谱上，就可以理解为拥有同一种关系的 头实体和尾实体对，在向量空间的表示可能具有平移不变性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaoqi/tag/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/&quot;&gt;https://www.cnblogs.com/xiaoqi/tag/知识图谱/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a</summary>
      
    
    
    
    <category term="知识图谱" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
    <category term="推理" scheme="http://yoursite.com/tags/%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Jaccard算法</title>
    <link href="http://yoursite.com/2023/09/08/Jaccard%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2023/09/08/Jaccard%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-08T03:09:40.000Z</published>
    <updated>2023-09-12T06:17:19.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杰卡德相似度"><a class="markdownIt-Anchor" href="#杰卡德相似度"></a> 杰卡德相似度</h2><p>选择待比较和比较实体</p><table><thead><tr><th style="text-align:left">待比较实体</th><th style="text-align:left">比较实体</th><th style="text-align:left">nGql</th></tr></thead><tbody><tr><td style="text-align:left">A、B、C</td><td style="text-align:left">D、E、F</td><td style="text-align:left">GET SUBGRAPH 0 to 1 STEPS FROM A、B、C、D、E、F  BOTH  allRelationTypes YIELD EDGES AS relationships</td></tr><tr><td style="text-align:left">A、B、C</td><td style="text-align:left">ALL</td><td style="text-align:left">GET SUBGRAPH 0 to 3 STEPS FROM A、B、C BOTH  allRelationTypes YIELD EDGES AS relationships</td></tr></tbody></table><p>筛选出待比较和比较实体的子图，根据边计算节点间相似度，即会过滤掉子图里的独立节点。</p><p>使用MinHashLSH计算</p><p>假设筛选出来子图，有n个节点，他们邻居如下：</p><table><thead><tr><th>row</th><th>A的邻居</th><th>B的邻居</th><th>C的邻居</th><th>D的邻居</th><th>其他点的邻居</th></tr></thead><tbody><tr><td>0</td><td>B</td><td></td><td>A</td><td>A</td><td>A</td></tr><tr><td>1</td><td>C</td><td>C</td><td></td><td>C</td><td></td></tr><tr><td>2</td><td>D</td><td>D</td><td>B</td><td></td><td>C</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>n</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在Jaccard计算上，量化算法公式：</p><p><img src="https://pic2.zhimg.com/80/v2-77df5e3c6a0f0f042b3e982571a5c901_720w.webp" alt="img"></p><p>它计算的结果会很精确，但是效率很低，因为检查了每一对集合里所有元素，此外，可能点之间相似度很低或者不相似，些检测是”浪费了计算时间”。</p><p>min-hash本质是一种降维手段。算法需要在对比集合相似度之前，先将需要对比点i和j的集合Ci、Cj进行一次最小哈希操作来降低集合的维度，得到其<strong>哈希签名sig(Ci)、sig（Cj）</strong> ，这便是上述定义里所提到的降维功能。 这时候我们再来对比<strong>sig(Ci)、sig（Cj）</strong> 之间的Jaccard距离即可，由于随机性，min-hash值对应的元素属于两个集合的交集的概率即是<img src="https://nos.netease.com/cloud-website-bucket/20180808092813ba1072bd-3b64-46ce-a473-d799f5be335b.png" alt="img">，我们可以将min-hash算法的公式总结如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minhash(Ci,Cj)=Jaccard(sig(Ci),sig(Cj))</span><br></pre></td></tr></table></figure><p>lsh局部敏感哈希本质是一种最大程度发现相似向量手段。使用min-hash可以降低比较点邻居的维度，但是比较点数量本身可能也包含数百万甚至<em>数十亿</em>个样本的数据集，这个时候找节点对时间复杂度还是<img src="https://nos.netease.com/cloud-website-bucket/201808080938471907fbed-fe0e-4481-a08b-9c92b717e97d.png" alt="img">。 所以，需要使用lsh方法来减少比较次数。理想情况下，我们只想比较我们认为是潜在匹配项或<em>候选对的</em>向量。lsh函数允许我们对同一样本进行多次分段和哈希处理。<em>当我们发现一对向量至少一次</em>被哈希为相同的值时，我们将它们标记为候选对- 即潜在匹配。</p><p>lsh的具体做法是在min-hash所得的哈希签名signature向量的基础上，将每一个向量分为几段，称之为band（即b），每个band包含r行，如果两个向量的其中一个或多个band相同，那么这两个向量就可能相似度较高；相同的band数越多，其相似度高的可能性越大。在任意一个band上被分到同一个桶内的点就互为candidate相似点，这样只需要计算所有candidate点的相似度就可以找到每个点的相似度。</p><p>示例：长度为 9 的两signature被分为 b = 3 个带，每个带包含 r = 3 行。每个子向量被散列到 k 个可能的桶之一中。由于第二个带中存在匹配（两个子向量具有相同的哈希值），因此我们将这些签名中的一对视为最近邻居的候选者。如下图：</p><p><img src="/2023/09/08/Jaccard%E7%AE%97%E6%B3%95/C:%5CUsers%5Ch2484%5CDesktop%5Cblog%5Cblog%5Csource_posts%5Cimage-20230912112005439.png" alt="image-20230912112005439"></p><p>对b和r的不同值可以构建不同的线图，如下：</p><p><img src="/2023/09/08/Jaccard%E7%AE%97%E6%B3%95/C:%5CUsers%5Ch2484%5CDesktop%5Cblog%5Cblog%5Csource_posts%5Cband.webp" alt="band"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;杰卡德相似度&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#杰卡德相似度&quot;&gt;&lt;/a&gt; 杰卡德相似度&lt;/h2&gt;
&lt;p&gt;选择待比较和比较实体&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:le</summary>
      
    
    
    
    <category term="图算法" scheme="http://yoursite.com/categories/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Jaccard" scheme="http://yoursite.com/tags/Jaccard/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2023/08/03/nebulaGraph%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2023/08/03/nebulaGraph%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/</id>
    <published>2023-08-03T11:58:25.784Z</published>
    <updated>2023-08-04T03:12:53.031Z</updated>
    
    <content type="html"><![CDATA[<p>Used memory hits the high watermark(0.800000) of total system memory.</p><p><code>num_queries_hit_memory_watermark</code> 可以修改一下你的 graphd 里的 这个配置，重启一下 graphd 哈<br>默认是 0.8 表示 80% ，可以改成 0.9999</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Used memory hits the high watermark(0.800000) of total system memory.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;num_queries_hit_memory_watermark&lt;/code&gt; 可以修改一下你的 graph</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nebulaGraph使用</title>
    <link href="http://yoursite.com/2023/03/21/nebulaGraph%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2023/03/21/nebulaGraph%E4%BD%BF%E7%94%A8/</id>
    <published>2023-03-21T07:44:32.000Z</published>
    <updated>2023-03-21T09:13:18.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-space语句"><a class="markdownIt-Anchor" href="#1-space语句"></a> 1、Space语句</h2><p><a href="https://docs.nebula-graph.com.cn/3.3.0/3.ngql-guide/9.space-statements/1.create-space/">https://docs.nebula-graph.com.cn/3.3.0/3.ngql-guide/9.space-statements/1.create-space/</a></p><h3 id="11-新建空间"><a class="markdownIt-Anchor" href="#11-新建空间"></a> 1.1 新建空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#仅指定 VID 类型，其他选项使用默认值。</span><br><span class="line">create space IF NOT EXISTS my_space1(vid_type&#x3D;FIXED_STRING(30));</span><br><span class="line">#指定分片数量、副本数量、VID 类型</span><br><span class="line">CREATE SPACE IF NOT EXISTS my_space_2 (partition_num&#x3D;15, replica_factor&#x3D;1, vid_type&#x3D;FIXED_STRING(30));                     #指定分片数量、副本数量、VID 类型，并添加描述。                       CREATE SPACE IF NOT EXISTS my_space_3 (partition_num&#x3D;15, replica_factor&#x3D;1, vid_type&#x3D;FIXED_STRING(30)) comment&#x3D;&quot;测试图空间&quot;; </span><br></pre></td></tr></table></figure><h3 id="12-克隆空间"><a class="markdownIt-Anchor" href="#12-克隆空间"></a> 1.2 克隆空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#新建空间4，克隆之空间3</span><br><span class="line">CREATE SPACE IF NOT EXISTS my_space_4 as my_space_3;</span><br></pre></td></tr></table></figure><h3 id="13-查看空间"><a class="markdownIt-Anchor" href="#13-查看空间"></a> 1.3 查看空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 全部空间</span><br><span class="line">SHOW SPACES;</span><br><span class="line"># 查看指定</span><br><span class="line">SHOW CREATE SPACE my_space_4;</span><br><span class="line">DESC SPACE my_space_4;</span><br></pre></td></tr></table></figure><h3 id="14-使用空间"><a class="markdownIt-Anchor" href="#14-使用空间"></a> 1.4 使用空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE SPACE my_space_4;</span><br></pre></td></tr></table></figure><h3 id="15-清空空间"><a class="markdownIt-Anchor" href="#15-清空空间"></a> 1.5 清空空间</h3><p><code>CLEAR SPACE</code>语句用于清空图空间中的点和边，但不会删除图空间本身以及其中的 Schema 信息。</p><ul><li>数据清除后，<strong>如无备份，无法恢复</strong>。使用该功能务必谨慎。</li><li><code>CLEAR SPACE</code>不是原子性操作。如果执行出错，请重新执行，避免残留数据。</li><li>图空间中的数据量越大，<code>CLEAR SPACE</code>消耗的时间越长。如果<code>CLEAR SPACE</code>的执行因客户端连接超时而失败，可以增大 <a href="https://docs.nebula-graph.com.cn/3.3.0/5.configurations-and-logs/1.configurations/3.graph-config/">Graph 服务配置</a>中<code>storage_client_timeout_ms</code>参数的值。</li><li><code>CLEAR SPACE</code>不会删除的数据包括：<ul><li>Tag 信息。</li><li>Edge type 信息。</li><li>原生索引和全文索引的元数据。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLEAR SPACE my_space_4;</span><br></pre></td></tr></table></figure><h3 id="16-删除空间"><a class="markdownIt-Anchor" href="#16-删除空间"></a> 1.6 删除空间</h3><p>会删除空间和其中<strong>所有信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SPACE my_space_4;</span><br></pre></td></tr></table></figure><p>执行<code>DROP SPACE</code>语句删除图空间后，为什么磁盘的大小没变化？</p><p>答：如果使用 3.1.0 之前版本的 NebulaGraph, <code>DROP SPACE</code>语句仅删除指定的逻辑图空间，不会删除硬盘上对应图空间的目录和文件。如需删除硬盘上的数据，需手动删除相应文件的路径，文件路径为<code>&lt;nebula_graph_install_path&gt;/data/storage/nebula/&lt;space_id&gt;</code>。其中<code>&lt;space_id&gt;</code>可以通过<code>DESCRIBE SPACE &#123;space_name&#125;</code>查看。</p><h2 id="2-tag语句"><a class="markdownIt-Anchor" href="#2-tag语句"></a> 2、Tag语句</h2><p>nGQL 中的 Tag 和 openCypher 中的 Label 相似，但又有所不同，例如它们的创建方式。</p><ul><li>openCypher 中的 Label 需要在<code>CREATE</code>语句中与点一起创建。</li><li>nGQL 中的 Tag 需要使用<code>CREATE TAG</code>语句独立创建。Tag 更像是 MySQL 中的表。</li></ul><h3 id="21-新建标签"><a class="markdownIt-Anchor" href="#21-新建标签"></a> 2.1 新建标签</h3><p>尝试使用新创建的 Tag 可能会失败，因为创建是异步实现的。为确保数据同步，后续操作能顺利进行，请等待 2 个心跳周期（20 秒）。</p><p>如果需要修改心跳间隔，请为<a href="https://docs.nebula-graph.com.cn/3.3.0/5.configurations-and-logs/1.configurations/1.configurations/">所有配置文件</a>修改参数<code>heartbeat_interval_secs</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TAG IF NOT EXISTS player(name string, age int);</span><br><span class="line"># 创建没有属性的 Tag。</span><br><span class="line">CREATE TAG IF NOT EXISTS no_property(); </span><br><span class="line"># 创建包含默认值的 Tag。</span><br><span class="line">CREATE TAG IF NOT EXISTS player_with_default(name string, age int DEFAULT 20);</span><br><span class="line"># 对字段 create_time 设置 TTL 为 100 秒。</span><br><span class="line">CREATE TAG IF NOT EXISTS woman(name string, age int, \</span><br><span class="line">        married bool, salary double, create_time timestamp) \</span><br><span class="line">        TTL_DURATION &#x3D; 100, TTL_COL &#x3D; &quot;create_time&quot;;</span><br></pre></td></tr></table></figure><h3 id="22删除标签"><a class="markdownIt-Anchor" href="#22删除标签"></a> 2.2删除标签</h3><ul><li>DROP删除所有点的tag</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TAG test;</span><br></pre></td></tr></table></figure><p>点可以有一个或多个 Tag。</p><ul><li><p>如果某个点只有一个 Tag，删除这个 Tag 后，用户就<strong>无法访问</strong>这个点，下次 Compaction 操作时会删除该点，但与该点相邻的<strong>边仍然存在</strong>——这会造成悬挂边。</p></li><li><p>如果某个点有多个 Tag，删除其中一个 Tag，仍然可以访问这个点，但是<strong>无法访问</strong>已删除 Tag 所定义的所有属性。</p></li></ul><p>删除 Tag 操作<strong>仅删除 Schema 数据</strong>，硬盘上的文件或目录不会立刻删除，而是在下一次 Compaction 操作时删除。</p><ul><li>DELETE删除指定点上的指定 Tag。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#VID：指定要删除tag的点 ID。</span><br><span class="line">DELETE TAG &lt;tag_name_list&gt; FROM &lt;VID&gt;;</span><br><span class="line">INSERT VERTEX test1(p1, p2),test2(p3, p4) VALUES &quot;test&quot;:(&quot;123&quot;, 1, &quot;456&quot;, 2);</span><br><span class="line">DELETE TAG test1 FROM &quot;test&quot;;</span><br></pre></td></tr></table></figure><h3 id="23修改标签"><a class="markdownIt-Anchor" href="#23修改标签"></a> 2.3修改标签</h3><p>尝试使用刚修改的 Tag 可能会失败，因为修改是异步实现的。为确保数据同步，后续操作能顺利进行，请等待 2 个心跳周期（20 秒）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TAG IF NOT EXISTS t1 (p1 string, p2 int);</span><br><span class="line">ALTER TAG t1 ADD (p3 int, p4 string);</span><br><span class="line">ALTER TAG t1 TTL_DURATION &#x3D; 2, TTL_COL &#x3D; &quot;p2&quot;;</span><br><span class="line">ALTER TAG t1 COMMENT &#x3D; &#39;test1&#39;;</span><br><span class="line">ALTER TAG t1 ADD (p5 double NOT NULL DEFAULT 0.4 COMMENT &#39;p5&#39;) COMMENT&#x3D;&#39;test2&#39;;</span><br></pre></td></tr></table></figure><h3 id="24查看标签"><a class="markdownIt-Anchor" href="#24查看标签"></a> 2.4查看标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#全部</span><br><span class="line">show tags;</span><br><span class="line"># 指定tag</span><br><span class="line">desc tag tag_name;</span><br></pre></td></tr></table></figure><h2 id="3-edge语句"><a class="markdownIt-Anchor" href="#3-edge语句"></a> 3、Edge语句</h2><p>nGQL 中的 Edge type 和 openCypher 中的关系类型相似，但又有所不同，例如它们的创建方式。</p><ul><li>openCypher 中的关系类型需要在<code>CREATE</code>语句中与点一起创建。</li><li>nGQL 中的 Edge type 需要使用<code>CREATE EDGE</code>语句独立创建。Edge type 更像是 MySQL 中的表。</li></ul><h3 id="31-新建边"><a class="markdownIt-Anchor" href="#31-新建边"></a> 3.1  新建边</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 创建没有属性的 Edge type。</span><br><span class="line">CREATE EDGE IF NOT EXISTS no_property();</span><br><span class="line"># 创建包含默认值的 Edge type。</span><br><span class="line">CREATE EDGE IF NOT EXISTS follow_with_default(degree int DEFAULT 20);</span><br><span class="line"># 对字段 p2 设置 TTL 为 100 秒。</span><br><span class="line">CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int, p3 timestamp) \</span><br><span class="line">        TTL_DURATION &#x3D; 100, TTL_COL &#x3D; &quot;p2&quot;;</span><br></pre></td></tr></table></figure><h3 id="32-删除边"><a class="markdownIt-Anchor" href="#32-删除边"></a> 3.2 删除边</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int);</span><br><span class="line">DROP EDGE e1;</span><br></pre></td></tr></table></figure><p>确保 Edge type 不包含任何索引，否则<code>DROP EDGE</code>时会报冲突错误<code>[ERROR (-1005)]: Conflict!</code>。删除索引请参见 <a href="https://docs.nebula-graph.com.cn/3.3.0/3.ngql-guide/14.native-index-statements/6.drop-native-index/">drop index</a>。</p><p>一个边只能有一个 Edge type，删除这个 Edge type 后，用户就<strong>无法访问</strong>这个边，下次 Compaction 操作时会删除该边。</p><p>删除 Edge type 操作仅删除 Schema 数据，硬盘上的文件或目录不会立刻删除，而是在下一次 Compaction 操作时删除。</p><h3 id="32-修改边"><a class="markdownIt-Anchor" href="#32-修改边"></a> 3.2 修改边</h3><p>确保要修改的属性不包含索引，否则<code>ALTER EDGE</code>时会报冲突错误<code>[ERROR (-1005)]: Conflict!</code>。删除索引请参见 <a href="https://docs.nebula-graph.com.cn/3.3.0/3.ngql-guide/14.native-index-statements/6.drop-native-index/">drop index</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int);</span><br><span class="line">ALTER EDGE e1 ADD (p3 int, p4 string);</span><br><span class="line">ALTER EDGE e1 TTL_DURATION &#x3D; 2, TTL_COL &#x3D; &quot;p2&quot;;</span><br><span class="line">ALTER EDGE e1 COMMENT &#x3D; &#39;edge1&#39;;</span><br></pre></td></tr></table></figure><h3 id="32-查看边"><a class="markdownIt-Anchor" href="#32-查看边"></a> 3.2 查看边</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 全部</span><br><span class="line">SHOW EDGES;</span><br><span class="line"># 指定type</span><br><span class="line">DESC[RIBE] EDGE &lt;edge_type_name&gt;</span><br></pre></td></tr></table></figure><h2 id="4-vertex语句"><a class="markdownIt-Anchor" href="#4-vertex语句"></a> 4、Vertex语句</h2><h3 id="41-新增点"><a class="markdownIt-Anchor" href="#41-新增点"></a> 4.1 新增点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># IF NOT EXISTS 仅检测 VID + Tag 的值是否相同，不会检测属性值。</span><br><span class="line"># IF NOT EXISTS 会先读取一次数据是否存在，因此对性能会有明显影响。</span><br><span class="line">INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]</span><br><span class="line">VALUES VID: ([prop_value_list])</span><br><span class="line"># 一次插入 2 个点。          </span><br><span class="line">INSERT VERTEX t2 (name, age) VALUES &quot;13&quot;:(&quot;n3&quot;, 12), &quot;14&quot;:(&quot;n4&quot;, 8); </span><br><span class="line"># 一次插入两个 Tag 的属性到同一个点。                                                         </span><br><span class="line">INSERT VERTEX  t3 (p1), t4(p2) VALUES &quot;21&quot;: (321, &quot;hello&quot;);</span><br><span class="line">              </span><br></pre></td></tr></table></figure><h3 id="42-删除点"><a class="markdownIt-Anchor" href="#42-删除点"></a> 4.2 删除点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="43-修改点"><a class="markdownIt-Anchor" href="#43-修改点"></a> 4.3 修改点</h3><h3 id="44"><a class="markdownIt-Anchor" href="#44"></a> 4.4</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-space语句&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-space语句&quot;&gt;&lt;/a&gt; 1、Space语句&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.nebula-graph.com.cn/3.3.0/3.n</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>spring框架使用技巧</title>
    <link href="http://yoursite.com/2023/03/20/spring%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-0/"/>
    <id>http://yoursite.com/2023/03/20/spring%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-0/</id>
    <published>2023-03-20T09:09:43.000Z</published>
    <updated>2023-03-22T12:31:45.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ioc启动流程"><a class="markdownIt-Anchor" href="#1-ioc启动流程"></a> 1、IOC启动流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、检验配置文件格式</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// 获取 Spring 容器，默认是DefaultListableBeanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean 等</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// BeanFactory 准备工作完成后进行的后置处理工作，hook方法</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">//=======以上是 BeanFactory 的预准备工作=======</span></span><br><span class="line">            <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory方法</span></span><br><span class="line">            <span class="comment">// SpringBoot 会在这里扫描 @Component 注解和进行自动配置</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 注册和创建 BeanPostProcessor 的实现类（注意和之前的 BeanFactoryPostProcessor 的区别）</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 初始化 MessageSource 组件（做国际化功能；消息绑定，消息解析）</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// 初始化当前 ApplicationContext 的事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前），Spring Boot 中新建webServer</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// 初始化所有的 singleton beans（lazy-init 的除外）</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// 容器刷新完成操作，会完成webServer启动</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            destroyBeans();</span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-obtainfreshbeanfactory"><a class="markdownIt-Anchor" href="#11-obtainfreshbeanfactory"></a> 1.1 obtainFreshBeanFactory</h2><p>DefaultListableBeanFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刷新容器，解析注册xml方式beanDenfinition到BeanFactory中</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line">             <span class="comment">// 设置是否允许同名覆盖，循环依赖</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">             <span class="comment">// xml定义bean，加载BeanDefinitions</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-invokebeanfactorypostprocessors"><a class="markdownIt-Anchor" href="#12-invokebeanfactorypostprocessors"></a> 1.2 invokeBeanFactoryPostProcessors</h2><p>整个 invokeBeanFactoryPostProcessors 方法围绕两个接口，<strong>BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor</strong>，其中 BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor 。</p><p>BeanDefinitionRegistryPostProcessor 主要用来在常规 BeanFactoryPostProcessor 检测开始之前注册其他 Bean 定义，说的简单点，就是 BeanDefinitionRegistryPostProcessor 具有更高的优先级，执行顺序在 BeanFactoryPostProcessor 之前。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AbstractApplicationContext#refresh() --&gt; </span><br><span class="line">AbstractApplicationContext#invokeBeanFactoryPostProcessors() --&gt; </span><br><span class="line">PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors() --&gt; PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors() --&gt; </span><br><span class="line"><span class="comment">//开始，BeanDefinitionRegistryPostProcessor(BeanFactoryPostProcessor)</span></span><br><span class="line">ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry（）--&gt; </span><br><span class="line">ConfigurationClassPostProcessor#processConfigBeanDefinitions() --&gt; </span><br><span class="line">ConfigurationClassPostProcessor#parse() --&gt; </span><br><span class="line">ConfigurationClassPostProcessor#processConfigurationClass() --&gt;</span><br><span class="line">ConfigurationClassParser#parse() --&gt;</span><br><span class="line"><span class="comment">// 配置注解 @Configuration @Bean @Import @ImportSelector </span></span><br><span class="line">ConfigurationClassParser#doProcessConfigurationClass() --&gt;</span><br><span class="line">ComponentScanAnnotationParser#parse() --&gt; </span><br><span class="line"><span class="comment">// 扫描注解    </span></span><br><span class="line">ClassPathBeanDefinitionScanner#doScan() --&gt; </span><br><span class="line">ClassPathScanningCandidateComponentProvider#findCandidateComponents() --&gt; ClassPathScanningCandidateComponentProvider#scanCandidateComponents</span><br></pre></td></tr></table></figure><ul><li>加载 xml 配置文件</li></ul><p>​发生在基于 xml 配置文件的 ApplicationContext 中 refresh 方法的 BeanFactory 初始化阶段，此时 BeanFactory 刚刚构建完成，它会借助 XmlBeanDefinitionReader 来加载 xml 配置文件，并使用 DefaultBeanDefinitionDocumentReader 解析 xml 配置文件，封装声明的 <bean> 标签内容并转换为 BeanDefinition 。</bean></p><ul><li>解析注解配置类</li></ul><p>​发生在 ApplicationContext 中 refresh 方法的 BeanDefinitionRegistryPostProcessor 执行阶段，该阶段首先会执行 ConfigurationClassPostProcessor 的 postProcessBeanDefinitionRegistry 方法。ConfigurationClassPostProcessor 中会找出所有的配置类，排序后依次解析，并借助 ClassPathBeanDefinitionScanner 实现包扫描的 BeanDefinition 封装，借助 ConfigurationClassBeanDefinitionReader 实现 @Bean 注解方法的 BeanDefinition 解析和封装。</p><ul><li>编程式构造</li></ul><p>​  BeanDefinition 也是发生在 ApplicationContext 中 refresh 方法的 BeanDefinitionRegistryPostProcessor 执行阶段，由于 BeanDefinitionRegistryPostProcessor 中包含 ConfigurationClassPostProcessor ，而 ConfigurationClassPostProcessor 会执行 ImportBeanDefinitionRegistrar 的逻辑，从而达到编程式构造 BeanDefinition 并注入到 BeanDefinitionRegistry 的目的；另外，实现了 BeanDefinitionRegistryPostProcessor 的类也可以编程式构造 BeanDefinition ，注入 BeanDefinitionRegistry 。</p><h2 id="13-finishbeanfactoryinitialization"><a class="markdownIt-Anchor" href="#13-finishbeanfactoryinitialization"></a> 1.3  finishBeanFactoryInitialization</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 处理bean的alias</span></span><br><span class="line">    String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">// 循环依赖的探测</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// logger ......</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">        <span class="comment">// 如果原型bean之间互相依赖，则一定会引发无限循环，此处会抛出循环依赖的异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        <span class="comment">// 如果本地不存在当前bean的定义信息，则尝试让父容器实例化bean</span></span><br><span class="line">        <span class="comment">// 此举可以保证每个BeanFactory持有它应该有的bean，而不是所有的bean都集中在某一个BeanFactory中</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                        nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else if parentBeanFactory.getBean ......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记当前bean已经开始被创建了</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 此处会合并BeanDefinition，并检查是否为抽象类(abstract则会抛出无法实例化的异常)</span></span><br><span class="line">            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            <span class="comment">// 此处会处理</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="comment">// 循环依赖的检查：如果两个bean互相显式依赖，也会引发循环依赖的问题</span></span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 迫切初始化显式依赖的bean</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125; <span class="comment">// catch ......</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="comment">// 单实例bean的初始化，最终调用createBean</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; <span class="comment">// catch ......</span></span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原型bean的初始化，直接调用createBean</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理自定义的scope ......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// catch ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类型强转前的检查 ......</span></span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Spring首先从singletonObjects（一级缓存）中尝试获取</span></span><br><span class="line">  Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="comment">// 若是获取不到而且对象在建立中，则尝试从earlySingletonObjects(二级缓存)中获取</span></span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">          ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//若是仍是获取不到而且允许从singletonFactories经过getObject获取，则经过singletonFactory.getObject()(三级缓存)获取</span></span><br><span class="line">              singletonObject = singletonFactory.getObject();</span><br><span class="line">              <span class="comment">//若是获取到了则将singletonObject放入到earlySingletonObjects,也就是将三级缓存提高到二级缓存中</span></span><br><span class="line">              <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">              <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一级缓存，存放创建完成，初始完成的bean</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">//三级缓存，存放bean工厂</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//二级缓存（？），循环依赖中用到，三级缓存创建bean，此时刚创建完，值没有设置</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/03/20/spring%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-0/.%5Cimage-20230321201304795.png" alt="image-20230321201304795"></p><p><strong>Spring 一开始提前暴露的并不是实例化的 Bean，而是将 Bean 包装起来的 ObjectFactory。为什么要这么做呢？</strong></p><p>这实际上涉及到 AOP，如果创建的 Bean 是有代理的，那么注入的就应该是代理 Bean，而不是原始的 Bean。但是 Spring 一开始并不知道 Bean 是否会有循环依赖，通常情况下（没有循环依赖的情况下），Spring 都会在完成填充属性，并且执行完初始化方法之后再为其创建代理。但是，如果出现了循环依赖的话，Spring 就不得不为其提前创建代理对象，否则注入的就是一个原始对象，而不是代理对象。<strong>所以Spring 需要三级缓存的目的是为了在没有循环依赖的情况下，延迟代理对象的创建，使 Bean 的创建符合 Spring 的设计原则。</strong></p><h1 id="2-ioc的扩展点"><a class="markdownIt-Anchor" href="#2-ioc的扩展点"></a> 2、IOC的扩展点</h1><ul><li><table><thead><tr><th>扩展接口</th><th>作用</th></tr></thead><tbody><tr><td>BeanFactoryPostProcessor</td><td>修改/新增容器中的 BeanDefinition</td></tr><tr><td>BeanDefinitionRegistryPostProcessor</td><td>可以添加自定义的Bean</td></tr><tr><td>BeanPostProcessor</td><td>支持在 Bean 初始化前后，对 Bean 进行处理</td></tr><tr><td>initializingBean</td><td>在 Bean实例化完成，所有属性注入完成之后执行</td></tr><tr><td>DisposableBean</td><td>在 Bean 销毁前执行</td></tr><tr><td>Aware 接口族</td><td>获得 Spring 容器资源</td></tr><tr><td>FactoryBean</td><td>复杂 Bean 注入</td></tr><tr><td>ApplicationListener</td><td>监听响应容器事件</td></tr></tbody></table></li></ul><h3 id="21-beanfactorypostprocessor"><a class="markdownIt-Anchor" href="#21-beanfactorypostprocessor"></a> 2.1 BeanFactoryPostProcessor</h3><p>它是在refresh方法的<code>invokeBeanFactoryPostProcessors</code>方法里调用的。</p><ul><li>修改BeanDefinition</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IOC 容器调用了MyBeanFactoryPostProcessor中重写的postProcessBeanFactory方法&quot;</span>);</span><br><span class="line"><span class="comment">// 获取Bean定义名称，进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String name:beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line"><span class="comment">// 如果是person对象</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;person&quot;</span>.equals(name)) &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;将Person对象设置为懒加载&quot;</span>);</span><br><span class="line">                <span class="comment">// 获取person的BeanDefinition(Bean定义对象)</span></span><br><span class="line">                BeanDefinition beanDefinition = beanFactory.getBeanDefinition(name); </span><br><span class="line">                <span class="comment">// 将Person对象设置为懒加载</span></span><br><span class="line">                beanDefinition.setLazyInit(<span class="keyword">true</span>);   </span><br><span class="line">                <span class="comment">//修改属性的值</span></span><br><span class="line">                 beanDefinition.getPropertyValues().add(<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加载BeanDefinition</li></ul><p>springBoot 中通过<code>ConfigurationClassPostProcessor</code>后置处理器加载注册了Java配置类、注解扫描方式的bean的BeanDefinitions到BeanFactory中。</p><h3 id="22-beandefinitionregistrypostprocessor"><a class="markdownIt-Anchor" href="#22-beandefinitionregistrypostprocessor"></a> 2.2 BeanDefinitionRegistryPostProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册Bean定义，容器根据定义返回bean</span></span><br><span class="line">        log.info(<span class="string">&quot;开始在注册自定义beanDefinition到容器&quot;</span>);</span><br><span class="line">        <span class="comment">//构造bean定义</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder</span><br><span class="line">                .genericBeanDefinition(UserInfoVO.class);</span><br><span class="line">        <span class="comment">//设置依赖</span></span><br><span class="line">        beanDefinitionBuilder.addPropertyReference(<span class="string">&quot;MyUser&quot;</span>, <span class="string">&quot;myUser&quot;</span>);</span><br><span class="line">        BeanDefinition personManagerBeanDefinition = beanDefinitionBuilder</span><br><span class="line">                .getRawBeanDefinition();</span><br><span class="line">        <span class="comment">//注册bean定义</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;myUser&quot;</span>, personManagerBeanDefinition);</span><br><span class="line">        log.info(<span class="string">&quot;结束在注册自定义beanDefinition到容器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        BeanDefinition myUser = beanFactory.getBeanDefinition(<span class="string">&quot;myUser&quot;</span>);</span><br><span class="line">        myUser.getPropertyValues().add(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FactoryBean</li><li>InitializingBean、ApplicationContextAware、DisposableBean、@PostConstruct、@PreDestroy注解</li><li></li><li></li><li>PropertySourceLoader</li><li>ApplicationContextInitializer</li><li>EnvironmentPostProcessor</li><li>ApplicationRunner和CommandLineRunner</li><li>BeanFactoryAware</li><li>ApplicationContextAwareProcessor</li><li>BeanNameAware</li><li>SmartInitializingSingleton</li><li>DisposableBean</li><li>ApplicationListener</li></ul><h1 id="3-webmvc扩展点"><a class="markdownIt-Anchor" href="#3-webmvc扩展点"></a> 3、WebMvc扩展点</h1><ul><li>HandlerMapping</li><li>HandlerInterceptor</li><li>HandlerAdapter</li><li>HandlerMethodArgumentResolver</li><li>Converter</li><li>ViewResolver</li><li>HandlerExceptionResolver</li><li>WebMvcConfigurer</li></ul><h1 id="4-自动装配"><a class="markdownIt-Anchor" href="#4-自动装配"></a> 4、自动装配</h1><h1 id="5-编写自己starter"><a class="markdownIt-Anchor" href="#5-编写自己starter"></a> 5、编写自己starter</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-ioc启动流程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-ioc启动流程&quot;&gt;&lt;/a&gt; 1、IOC启动流程&lt;/h1&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring框架使用技巧</title>
    <link href="http://yoursite.com/2023/03/13/Spring%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2023/03/13/Spring%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2023-03-13T05:37:16.000Z</published>
    <updated>2023-03-17T03:25:30.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ioc启动流程"><a class="markdownIt-Anchor" href="#1-ioc启动流程"></a> 1、IOC启动流程</h1><p>refresh方法一共分成12个步骤，每个步骤解释如下：</p><ol><li>prepareRefresh() 容器启动前的准备工作</li><li>obtainFreshBeanFactory() 告诉子类刷新内部Bean工厂,解析Bean并注册到容器中（此时还没有初始化）</li><li>prepareBeanFactory(beanFactory) 准备BeanFactory，设置beanFactory类加载器，添加多个beanPostProcesser</li><li>postProcessBeanFactory(beanFactory) 允许子类上下文中对beanFactory做后期处理</li><li>invokeBeanFactoryPostProcessors(beanFactory) 调用BeanFactoryPostProcessor各个实现类的方法</li><li>registerBeanPostProcessors(beanFactory) 注册 BeanPostProcessor 的实现类</li><li>initMessageSource() 初始化ApplicationContext的MessageSource</li><li>initApplicationEventMulticaster() 初始化事件广播</li><li>onRefresh() 初始化子类特殊bean</li><li>registerListeners() 注册事件监听器</li><li>finishBeanFactoryInitialization(beanFactory) 初始化所有singleton bean</li><li>finishRefresh() 广播事件，ApplicationContext初始化完成</li></ol><p>总结：1 为准备环境；2-6 为准备 BeanFactory；7-12 为准备 ApplicationContext（其中11 为初始化 BeanFactory 中非延迟单例 bean）</p><h2 id="11-preparerefresh"><a class="markdownIt-Anchor" href="#11-preparerefresh"></a> 1.1 prepareRefresh</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//留给子类覆盖，初始化属性资源</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initPropertySources</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-obtainfreshbeanfactory"><a class="markdownIt-Anchor" href="#12-obtainfreshbeanfactory"></a> 1.2 obtainFreshBeanFactory</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-webmvc可扩展点"><a class="markdownIt-Anchor" href="#2-webmvc可扩展点"></a> 2、WebMvc可扩展点</h1><h1 id="3-自动装配"><a class="markdownIt-Anchor" href="#3-自动装配"></a> 3、自动装配</h1><h1 id="4-编写starter"><a class="markdownIt-Anchor" href="#4-编写starter"></a> 4、编写starter</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-ioc启动流程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-ioc启动流程&quot;&gt;&lt;/a&gt; 1、IOC启动流程&lt;/h1&gt;
&lt;p&gt;refresh方法一共分成12个步骤，每个步骤解释如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;prepareRe</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2023/02/08/Untitled/"/>
    <id>http://yoursite.com/2023/02/08/Untitled/</id>
    <published>2023-02-08T11:48:40.954Z</published>
    <updated>2023-02-08T12:07:40.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图谱信息列表"><a class="markdownIt-Anchor" href="#图谱信息列表"></a> 图谱信息列表</h2><blockquote><p>不需要鉴权，直接传参数调用就行。</p></blockquote><p><strong>接口地址</strong> <code>/kbstudio/thirdApi/graphInfoList</code></p><p><strong>请求方式</strong> <code>GET</code></p><p><strong>接口描述</strong> ``</p><p><strong>请求参数</strong></p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>是否必须</th><th>数据类型</th></tr></thead><tbody><tr><td>tenantId</td><td>租户id</td><td>true</td><td>integer</td></tr></tbody></table><p><strong>响应状态</strong></p><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>20000</td><td>请求成功</td></tr><tr><td>40001</td><td>参数缺失，例如tenantId为空</td></tr><tr><td>50001</td><td>服务器内部错误</td></tr></tbody></table><p><strong>响应格式示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;graphCount&quot;</span>:<span class="number">9</span>, <span class="comment">//所有图谱总个数</span></span><br><span class="line">        <span class="attr">&quot;entityLabelCount&quot;</span>:<span class="number">34</span>,<span class="comment">//所有图谱实体标签个数</span></span><br><span class="line">        <span class="attr">&quot;relationTypeCount&quot;</span>:<span class="number">20</span>,<span class="comment">//所有图谱关系类型个数</span></span><br><span class="line">        <span class="attr">&quot;entityInstanceCount&quot;</span>:<span class="number">22222</span>,<span class="comment">// 所有图谱实体实例个数</span></span><br><span class="line">        <span class="attr">&quot;relationInstanceCount&quot;</span>:<span class="number">43423432</span> <span class="comment">//所有图谱关系实例个数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;return_code&quot;</span>:<span class="number">20000</span>,</span><br><span class="line">    <span class="attr">&quot;return_msg&quot;</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图谱信息列表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#图谱信息列表&quot;&gt;&lt;/a&gt; 图谱信息列表&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;不需要鉴权，直接传参数调用就行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;接</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>扫描pdf添加类目</title>
    <link href="http://yoursite.com/2023/01/17/%E6%89%AB%E6%8F%8Fpdf%E6%B7%BB%E5%8A%A0%E7%B1%BB%E7%9B%AE/"/>
    <id>http://yoursite.com/2023/01/17/%E6%89%AB%E6%8F%8Fpdf%E6%B7%BB%E5%8A%A0%E7%B1%BB%E7%9B%AE/</id>
    <published>2023-01-17T02:39:51.000Z</published>
    <updated>2023-01-17T03:20:00.807Z</updated>
    
    <content type="html"><![CDATA[<p>往往下载的扫描版本的pdf是没有可以跳转的目录的，因此需要给扫描pdf添加可以跳转的目录，方便查阅。</p><ul><li>下载：FreePic2PDF</li></ul><p>链接：<a href="https://pan.baidu.com/s/1nCfdE5Sv3pu2wiFugX_GUQ">https://pan.baidu.com/s/1nCfdE5Sv3pu2wiFugX_GUQ</a><br>提取码：fhds</p><ul><li><p>提取目录</p><ul><li>打开软件FreePic2PDF，点击右下角“更改pdf”</li><li>选择“从PDF取书签”→选择你的pdf文件→点击开始</li><li>找到生成的文件</li></ul><p><img src="/2023/01/17/%E6%89%AB%E6%8F%8Fpdf%E6%B7%BB%E5%8A%A0%E7%B1%BB%E7%9B%AE/.%5Cimage-20230117104729156.png" alt="image-20230117104729156"></p></li><li><p>修改txt文件</p></li></ul><p>从豆瓣拷贝扫描pdf的目录到txt文件中，使用正则格式化目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一级目录</span><br><span class="line">^(\d&#123;1,2&#125;\.\d) 替换为  \t\1</span><br><span class="line">&#x2F;&#x2F; 二级目录</span><br><span class="line">^(\s\d&#123;1,2&#125;\.\d\.\d)   替换为 \t\t\1</span><br></pre></td></tr></table></figure><ul><li>挂载已经修改的txt</li><li>可以定义basePage页码再FreePic2Pdf.itf文件中</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;往往下载的扫描版本的pdf是没有可以跳转的目录的，因此需要给扫描pdf添加可以跳转的目录，方便查阅。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载：FreePic2PDF&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1nCfdE5S</summary>
      
    
    
    
    <category term="pdf" scheme="http://yoursite.com/categories/pdf/"/>
    
    
    <category term="添加类目" scheme="http://yoursite.com/tags/%E6%B7%BB%E5%8A%A0%E7%B1%BB%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>ALGO系列-相似度算法</title>
    <link href="http://yoursite.com/2023/01/16/ALGO%E7%B3%BB%E5%88%97-%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2023/01/16/ALGO%E7%B3%BB%E5%88%97-%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2023-01-16T05:37:16.000Z</published>
    <updated>2023-01-16T05:37:16.131Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
